
[{"content":" ","date":"2024-06-06","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":" ","title":"Blog","type":"blog"},{"content":"","date":"2024-06-06","externalUrl":null,"permalink":"/tags/emacs/","section":"Tags","summary":"","title":"Emacs","type":"tags"},{"content":"","date":"2024-06-06","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" 你好！我是小困熊，这里是我的博客之一。\n我关心前沿技术、个人成长、知识管理和内容创作。\n正在培养读书的习惯，所以我也会写写 读书笔记 。\n遇到有所感悟或启发的信息时，我会分享到 Twitter 和 Telegram 频道 。\n如果你好奇我 现在正在做的事情 ，或者了解更多 关于我 的信息。\n","date":"2024-06-06","externalUrl":null,"permalink":"/","section":"可爱的小困熊","summary":"你好！我是小困熊，这里是我的博客之一。","title":"可爱的小困熊","type":"page"},{"content":" Table of Contents # 简介 为什么用 Emacs (可选) 学会了Emacs就同时学会了其他编辑器 优秀的社区 编程速度更快 Emacs 会永存 可以立刻开始工作 一年指的是一年中的空闲时间 实事求是,戒骄戒躁 理解软件自由 避免门户之见 以科学理性做指导 具体步骤 无 Linux/Unix 经验新手的快速指南 (可选) 读官方教程 以实际问题作为切入点 待解决的问题设定优先度 站在巨人的肩膀上 报 bug 持续改进 加入社区更上一层楼 Reddit GitHub 是高手云集的地方 博客 在 Stack Overflow 上搜索相关讨论 到 Youtube 上看 emacs 相关的视频 读书最有效 EmacsWiki Emacs Lisp 书籍推荐 (可选) 知识管理 配置纳入 GitHub 的版本控制 将相关资料备份 第三方插件推荐 Emacs 是一种生活方式 付之于行动 使用 Evil Text Object Leader 键 Evil 兼容 Emacs 原生插件 Evil 专用的插件介绍 evil-surround evil-nerd-commenter evil-matchit evil-escape evil-visualstar 在 Shell 和 Interactive Interpreter 中使用 Evil Evil 的小结 答疑 新手怎么开始 如和理解他人配置 他人配置是否太重量级? 其他第三方配置 该使用 Emacs 的哪个版本 Vi 用户要转阵营吗? 为什么很多 Vi 用户不接受 Evil? 不习惯默认快捷键, 怎么办？ 使用第三方配置后有些奇怪的 bug, 怎么改? 已更新软件包, 但是没有任何作用, 也没有任何错误信息 有配置问题 启动报错 自己的简单配置好控制 自己加的插件无效 我想用 Windows 版本的 Emacs 而不是 Cygwin 版本, 怎么做? Emacs 在代码跳转和自动完成上和商业 IDE 有差距, 怎么办? 邮件 为什么 Emacs 启动时从服务器 (elpa) 安装第三方软件包 (package) 会失败? 有些网站 Emacs 访问不了 是否应尽早学习 Emacs Lisp 掌握 Emacs Lisp 是否是成为高手的必要条件? 有必要学习键盘宏 (Keyboard Macros) 吗? 基本操作我会了, 下一步学什么迷茫中 如何学习 org-mode? 对于 “一切都用 Emacs 来完成” 的观点你怎么看? 结语 简介 # 成为高手很容易. 我初学Emacs时常忘记“退出”的快捷键, 一年后我完全掌握了Emacs.\n一些文章强调Emacs有多牛, 但关于“如何做”则语焉不详. 即使涉及到“如何做”, 谈细节多而方法论少.\n很多人花了大量时间“学习”Emacs却最终放弃,就是因为过于拘泥细节,而方法论上出了问题.\n例如,初学者背少用的快捷键会有很大的挫折感.一个月记住50个快捷键后算很厉害了.但是Emacs可以配置快捷键的命令近7000个.如果记住所有快捷键等同于掌握Emacs的话,一个人需要花至少十年.99%的快捷键很少用,少用的按键很快就忘了.花了十年做了99%都是无用功的事情当然非常打击积极性.\n除本文之外的任何一本Emacs教程都会列出至少100个“常用”的快捷键.我不会刻意教你某个快捷键,但是会告诉你:\n一个人记住的快捷键数量和他的Emacs水平没有必然联系 20个甚至更少的快捷键够用了 常用的是哪些快捷键 其他按键在使用过程中会自然记住 我在快捷键这个问题上指明大方向,避免了记住7000个快捷键这个恐怖的任务,学习过程变轻松很多.\n这个例子说明了本文独特之处在于集中火力在“方法论”.\n方法论基于实践和经验总结,有事实证据支持.例如常用快捷键列表是用 keyfreq 的插件积累至6个月数据统计出来的.\n全文结构如下:\n为什么 Emacs 值得学习, 对开源文化熟悉可跳过这一章 实事求是,戒骄戒躁 充分利用高手成果, 不要重复发明轮子 尽快掌握 Emacs 的步骤 如何提高 (社区, 阅读, 知识管理) 跳出具体技巧, 重要的是人 答疑和小结 为什么用 Emacs (可选) # 虽然本文的重点是“怎么做”, 而不是“为什么”.但先解释一下Emacs的优秀之处很有必要.\n学会了Emacs就同时学会了其他编辑器 # Emacs的自由度高且历史悠久,所以即使常用的功能也比其他软件类似功能强大的多.\n切换到其他编辑器后,可以根据Emacs的独特经验优化自己的工作流.\n优秀的社区 # Emacs Lisp 不同寻常的语法决定了其开发者都是资深开发者, 掌握了多门语言.\n编程速度更快 # IDE 针对特定语言或框架优化, Emacs 完成通用任务更有效.\n例如, 我碰到难题需上 IRC 请教国外高手 (工作流是, 粘贴代码到 http://gist.github.com, 在 irc 提问, 看网页, 将解决方案粘贴回来), Emacs 集成了 IRC 工具和浏览器操作就很方便.\n口说无凭, 请看高手视频, abo-abo演示的查找替换技术\n顺便说一下, Emacs的“代码自动完成”和“代码导航”两个功能对主流编程语言支持都不错.\n“不错”的意思是达到90%的功能,是否能达到100%取决于安装了哪些插件. 达不到100%,适当妥协一下,90%也不错.\n不要斤斤计较在“代码自动完成”和“代码导航”要完全复制IDE的体验.而忽视了Emacs的在这两个功能上的特色.\n高级程序员对API早已熟悉,在大项目中的新代码和老代码相似.所以他们对“智能”不在意,对写代码速度更重视.\n例如web程序员需求在javascript文件写css和html代码. Emacs结合 Ctags 在同一代码文件自动完成javasscript\u0026amp;html\u0026amp;css,这显然很方便.\nEmacs 会永存 # 个人开发者会丧失兴趣, 公司会倒闭. 但自由软件基金会将一直存在下去.\nEmacs 作为其招牌软件也会维护下去, 投资永不会贬值.\n可以立刻开始工作 # 软件开源, 配置是纯文本, 且资源消耗小, 安装包很小 (命令行版本 30M 左右), 任何环境下都可用.\n这在大项目中特别有益, 例如, 某项目需同时编辑 Perl, Java, C, Bash, SQL, 要编辑远程服务器上的代码, 网速不快. Emacs 的优势就体现出来了.\n一年指的是一年中的空闲时间 # 我利用一年中通勤时间就取得了很大进步.\n实事求是,戒骄戒躁 # 理解软件自由 # 何为软件自由没有比自由软件基金会更权威了. 建议把 https://www.gnu.org/philosophy/free-sw.zh-cn.html 反复读, 理解何为四大自由.\n一旦真正理解了软件自由, Emacs 就变得非常简单了.\n例如, 很多用户习惯让 Emacs 启动时自动从其官方插件仓库 https://elpa.gnu.org 下载安装插件. 当该网站偶尔下线或者公司的防火墙拦截了对外网站访问时, Emacs 就会启动失败.\n这也就是一分钟可以解决的小事, 如果你理解软件自由, 有勇气 到 ~/.emacs.d/elpa/ 目录下看一看的话。\n一个插件仓库 (repository) 本质上就是一个文件夹, 它有一个含有插件列表名为 archive-contents 的文本文件, 以及一系列插件包. 你完全可以把这些文件下载下来, 在本地硬盘里建立 ELPA 的镜像.\n对个人来说, 安装 elpa-mirror 每年备份一下所有插件就足够了.\n避免门户之见 # 比如用了 Emacs 就排斥 Vim 的快捷键, 或者反之.\n避免门户之见的关键就是实事求是.\n以 Emacs 和 Vim 的快捷键为例, 两种快捷键完全可以无缝接合.\n以科学理性做指导 # 有读者反映我的方法类似于大学里写论文做研究, 事实上这正是我的灵感来源.\nEmacs 只是一种技术, 其学习方法和其它技术是通用的.\n打好基础, 让自己的知识有 足够的 广度和 适当的 深度, 对新手是最重要的. 否则会在一些琐碎问题上浪费时间.\n新手的错误是花大量时间记快捷键, 事实上网上教程列出的初学者“必知”快捷键不是必需的. 很少用到的快捷键直接输入对应命令就行了. 用 smex 或同类插件输入命令很高效.\n具体步骤 # 后文用到的命名惯例,\nC 表示按下 Ctrl 键, M 表示按下 Alt 键 M-x my-command 表示同时按下 Alt 和 X, 输入 “my-command”, 然后回车 无 Linux/Unix 经验新手的快速指南 (可选) # 建议,\n不安装任何第三方插件 掌握shell基本知识, 什么是环境变量, 什么是 stdin, stdout, pipe. 这些知识可以帮助用户理解 Emacs 如何和其他软件交互 读Emacs官方教程(快捷键 M-x help-with-tutorial-spec-language), 学会基本的文本操作 (大概十几个快捷键) 使用 Emacs 自带的 org-mode, org-mode 关键是用起来, 只要记住按 TAB 键是展开内容就可以了, 其他都不用学 Org-mode 是Emacs内置的插件.用来写文档,记笔记,管理个人工作事务等等. 有很多第三方插件拓展. 不是三言两语可以概况其功能的. 它最受欢迎的的特性是支持名为 GTD (Getting Things Done) 的工作流. 很多人认为 org-mode 是最好的GTD软件. 新手以此入门上手很快, 可以立刻提高自己的生产力.\n读官方教程 # 按以下步骤阅读教程:\n不安装任何插件打开 Emacs, 比如在 Shell 中运行命令 emacs -nw -Q M-x help-with-tutorial 打开教程 完成该教程仅需半小时.\n即使不用 Emacs 默认快捷键, 这步也是必须的, 不要跳过!\n最起码要知道以下命令,\nM-x describe-variable, 快捷键 C-h v, 查看变量的文档 M-x describe-function, 快捷键 C-h f, 查看命令的文档 M-x describe-key, 快捷键 C-h k, 查看快捷键的文档 以实际问题作为切入点 # 努力能很快得到回报, 会越学越有乐趣, 进入正反馈.\n例如, 我急需 GTD 的工具, 而 Emacs 的 Org-mode 是同类软件中最好的. 用 Org-mode 节省了时间后, 我对 Emacs 兴趣高涨.\n反面例子是啃Lisp教程开始Emacs之旅, 坚持下来的人寥寥无几.\n待解决的问题设定优先度 # 关键在于理性地考虑你最迫切需要解决的一个问题.\n以这个问题作为出发点, 除此之外都可以妥协.\n虽然 Emacs 无所不能, 但是饭也要一口一口吃. 有时退一步等于进两步.\n例如, 我一直以为 Emacs 的中文显示很完美, 搞不懂为什么有人在字体配置上花那么多时间.\n在读者反馈后, 才明白原来我一直在终端下使用Emacs, 终端软件可以完美显示中文字体, 所以就没 Emacs 什么事了. 需要配置字体的人用的是图形界面 Emacs.\n当初只在终端下使用 Emacs 是因为需连接到远程服务器. 我认为这是重点. 甚至为此放弃了漂亮的配色主题 (后来发觉此牺牲毫无必要). 塞翁失马, 由此也避免了图形界面版本的所有问题.\n站在巨人的肩膀上 # 刚开始我也是抱着玩的心态, 到处拷贝别人代码到我的配置中去. 浪费了很多时间.\n后来我停止折腾, 安心用 Steve Purcell 的 Emacs 配置 , 从此走上正轨.\n初学者开始阶段应以模仿为主. 这点是本文核心思想.\n之前提过, 我选择不背快捷键,而用smex优化输入命令的效率.这也是因为我使用他人成熟配置后学会的.\n考虑一下:\n我就是这么做的, 看看一年内我给他报了多少 bug 要超越高手就必须了解其高度, 你需要一年时间去模仿去学习 基于 Purcell 的配置给他报 bug (甚至是提交patch), 你就是考虑到了他未考虑到的问题, 至少在这点就超过他了, 日积月累就很可观了 报 bug # 像武侠小说那样拜高手为师是白日做梦. 唯一能让高手指点的办法是先付出. 最可靠的付出就是报 bug.\n我就是这样 学到一些高级 Lisp 技巧的.\n持续改进 # 要在高手已有工作上改善. 即使是微小的改善, 如果坚持一段时间, 就是巨大的进步了, 你就可以在这一点上笑傲江湖.\n再找出另一高手需要改善的地方, 使用同样的方法.\n例如, 默认在 Emacs 中移动子窗口焦点不是很方便. 需按 C-x o 多次. 我找到了 emacs 插件 switch-window, 只要按 C-x o 一次, 会有提示子窗口编号, 接下来输入编号就可以了. 但还有改善空间, 我又找到了 window-number.el, 只要按 M-NUM 一次. 这个方法已几乎完美, 但 Alt 键还是有点慢, 我结合 evil 和 evil-leader, 可以按逗号和数字飞速切换子窗口了. 我的这个点子后来被 spacemacs采用.现在已是大多数Emacs用户的标准配置了.\n加入社区更上一层楼 # 最重要的是专一. 不去定阅和 Emacs 无关的话题.\nReddit # Reddit 是最好的.\nGitHub 是高手云集的地方 # GitHub 的版本控制服务很好. 现在它的社区化倾向越来越强了, 我喜欢.\n例如, 可以看一下 https://github.com/search?p=1\u0026q=stars%3A%3E20+extension%3Ael+language%3Aelisp\u0026ref=searchresults\u0026type=Repositories 上最酷的 Emacs 插件.\n博客 # 最好的是 Planet EmacsLife, 多个 Emacs 博客的集合.\n在 Stack Overflow 上搜索相关讨论 # google “emacs-related-keywords site:stackoverflow.com”\n我会定期搜索, 同一帖子反复精读. 因为讨论质量很高.\nhttp://emacs.stackexchange.com 是 Stack Overflow 旗下专门的 Emacs 问答社区.\n到 Youtube 上看 emacs 相关的视频 # 我就是看了 Google Tech Talks 上这个 Org-mode 作者的介绍 而爱上 org-mode.\n不过 Youtube 搜索结果是最佳匹配的. 由于相关视频并不多, 如按照默认算法, 每次总是那几个. 所以如果关注最新进展, 搜索应以时间排序.\n读书最有效 # EmacsWiki # EmacsWiki 是社区维护的文档.\n有人抱怨文档太乱, 质量参差不齐. 前者我有同感. 后者不赞同. EmacsWiki 文档质量相当高, 因其是 唯一的 半官方文档. 忍受其乱中有序的现状吧.\n最佳阅读方法是, 选定一特定主题, 从头读到尾. 这样对最新进展都了解了. 是否要采用其建议另当别论.\nEmacs Lisp 书籍推荐 (可选) # Bob Glickstein 的 Writing GNU Emacs Extensions 是最好的.\n生动, 例子丰富. 作者用心安排了书的结构. 例如, 很早就介绍了 defadvice 的用法. defadvice 是 Emacs Lisp 的精华.\nXah Lee 提供 付费 Lisp 教程 也相当不错.\n知识管理 # 不要低估长时间的累积效应.\n例如 Steve Purcell 的配置. 2000 年开始维护,其质量不用我多费口舌.\n知识积累的越多, 这些知识之间的联系就会越多. 联系增长的速度是以指数的方式增长的. 如从头来过, 意味着积累知识的书面记录丢失了. 损失是很大的. 基数已归零, 增长的量又能有多少.\n这也是后文谈到为什么要用工具保存配置和知识的原因.\n配置纳入 GitHub 的版本控制 # 我的配置见 https://github.com/redguardtoo/emacs.d.\n版本控制可以认为是一个集中式的知识管理, 任何时刻任何地点对配置的修改都要及时上传合并 (merge). 这是积累能力的关键.\n共享实际也是一种利己行为, 很多人用我的配置等于帮我测试.\n将相关资料备份 # 我还写了许多博客文章. 这些文章都存在 org 格式的文件中. 最后发布的静态博客也纳入版本控制, 参见 http://github.com/redguardtoo/redguardtoo.github.io.\n第三方插件推荐 # 建议对少数优秀插件深入研究.阅读甚至编写相关代码.\n以下是清单：\n名称 说明 同类插件 Evil 将 Emacs 变为 Vim 没有 Org Org-mode, 全能的笔记和GTD工具 没有 company-mode 自动完成输入, 支持各种语言和后端 auto-complete yasnippet 强大的文本模板输入工具 没有 flymake 对不同语言做语法检查 flycheck ivy or helm 自动完成, 在其上有插件完成具体功能 ido magit 玩转 git 没有 Emacs 是一种生活方式 # Geek 其他方面也很牛. 举一反三你收获会很多.\nSacha Chua 就是这样的女孩, 这是她的 Youtube 录像. 她学习的方式是 让 Emacs 自动将手册语音合成, 这样她在房间里走来走去的时候也可以听文档了.\n我现在有意识地整理高手名单, 观察他们 除了 Emacs 外 用什么工具.\n例如, js2-mode 的维护者 Masafumi Oyamada (网名 mooz) 也开发了 keysnail 和 percol. 特别是 percol, 使我命令行效率提高了 10 倍.\n这个阶段可称之为 心中有剑, 手中无剑.\n是否用 Emacs 不重要了, 重要的是随心所欲. 例如, 很多人争论哪个编辑器自带的文件管理较好. 我 从 mooz 那学到大招后, 就跳出五行外, 不在三界中了.\n付之于行动 # 如何行动因人而异.\n关键是真正理解本文要点.\n例如，你是否意识到之前的章节意味着以下行动:\n找出所有插件的作者 在 Twitter/GitHub/Reddit 上跟随他们 通读他们已发表的贴子 使用 Evil # Evil 是 Vim 模拟器.\n如果你不熟悉 Vim, 在命令行里运行 vimtutor 或者安装 Emacs 插件 evil-tutor 学习 Vim 基本命令.\n该教程大概需要半小时. 关于 Vim 的基本操作的讨论就到此为止了. 网上教程汗牛充栋, 你可自行阅读.\n这里展示一些高级技巧 (有些技巧是我独创的).\nText Object # 了解 Vim Text Object 的概念.\nEvil 的强大之处就是你可以用 Emacs Lisp 来自定义 Text Object. 自由的 Lisp 使得你完全超越 Vim 的 “约定俗成”.\n比如在操作自定义的 Text Object 时, 当前焦点完全可以在 Text Object 之外. 这是 Lisp 写的 寻找附近的文件路径或者 URL. 用 Vim Script 写个类似的脚本难很多. 即使你用了 vim-textobj-user 之类的插件辅助开发也没用的.\n而且 Lisp 代码完全可以调用 任何 的第三方插件或者 Emacs 的不计其数的 API. 比如 Evil 中操作 Text Object 的过程中可以问用户问题, 访问网站等等.\n实现这些额外功能对 Vim 来说很难.\nLeader 键 # Vim 自带 Leader 键的功能, 你先按了 Leader 键 (很多人定义为空格键) 后, 再按其他键 (比如 kk) 会触发你自定义的命令. 本质就是给你更多的快捷键.\n在 Emacs 中需要使用第三方插件如 general.el 来实现此功能.\n某些 Vim 用户不能迁移到 Evil 的原因就是自定义了太多使用 Ctrl 键的快捷键, 和 Emacs 默认的快捷键有冲突.\n这些用户没有意识到的是借鉴 Emacs 的思想, 他们在 Vim 和 Emacs 的效率可以有巨大的提升. 我只提三点供参考:\n第一, 充分利用 Leader 快捷键. 我看过大多数 Vim 高手在 GitHub 上的设置, 他们一般定义 10 到 20 个 Leader 相关的快捷键.\n我定义了 300 个 相关的快捷键.\n典型 Evil 用户 (如 Spacemacs 用户) 大概有 3000 到 10000 个 相关快捷键可用.\n第二, Vim 用户的另一个问题是快捷键没有优化. 常用命令的快捷键应按. 何为常用命令须来自 真实数据.\n这是我用 Emacs 的插件 keyfreq 测试月的数据 (我的 Leader 键定义为逗号):\nTimes Percentage Command Key 4967 12.00% evilmi-jump-items % 2892 6.99% compile , o o 2178 5.26% find-file-in-project-by-selected , k k 1953 4.72% copy-to-x-clipboard , a a 1566 3.78% paste-from-x-clipboard , z z 1227 2.96% er/expand-region , x x 897 2.17% evil-repeat . 866 2.09% ido-find-file , x f, C-x C-f 819 1.98% toggle-full-window , f f 815 1.97% etags-select-find-tag-at-point C-], , h t 721 1.74% back-to-previous-buffer , b b 682 1.65% split-window-vertically , x 2 539 1.30% find-function , h f, C-h C-f 494 1.19% counsel-recentf-goto , r r 397 0.96% counsel-git-grep , g g 376 0.91% delete-other-windows , x 1, C-x 1 372 0.90% evilnc-comment-or-uncomment-lines , c i 351 0.85% eval-expression , e e, M-: 326 0.79% evilmi-select-items , s i 320 0.77% paredit-doublequote \u0026#xa0; 307 0.74% evil-filepath-outer-text-object \u0026#xa0; 300 0.72% steve-ido-choose-from-recentf \u0026#xa0; 295 0.71% split-window-horizontally , x 3 283 0.68% git-add-current-file , x v a 279 0.67% winner-undo , x u, , s u, C-x 4 u 278 0.67% describe-function , h d, C-h f 278 0.67% evil-goto-mark-line \u0026rsquo; 269 0.65% ido-kill-buffer , x k, C-x k 254 0.61% evil-goto-definition g d 253 0.61% pop-tag-mark M-* 251 0.61% git-messenger:popup-message , x v b, C-x v p 246 0.59% my-goto-next-hunk , n n 237 0.57% evilnc-comment-operator , , 235 0.57% flyspell-goto-next-error , f e, C-, 214 0.52% evil-exit-emacs-state \u0026#xa0; 212 0.51% browse-kill-ring-forward \u0026#xa0; 210 0.51% flyspell-buffer , f b 第三, 由于 Lisp 的强大 Leader 键的使用在 Emacs 中有无限可能\n使用 general.el 定义多个 Leader 键 可在切换文件时切换 Leader 键等等. Evil 兼容 Emacs 原生插件 # 如果你真正理解了我前面的章节, 这就根本不是问题.\n之前我提到了要保持头脑开放, 要尽可能抄高手的代码, 积极地报 bug 等观点. 现在让我演示一下如何应用.\n一开始我每装一个新的插件, 都要辛辛苦苦设置 evil 的快捷键.\n有一天我问自己, Lisp 那么强大, Evil 那么优秀, 也许有更方便简洁的方案?许多人说不行不一定是真理, 只有实际调查过的人才有发言权.\n我也没有自己钻研 Evil 的代码, 取而代之的是 给 Evil 的开发者 Frank Fischer 报了个 bug, 他给我了一个方案, 根本不需要重设快捷键.\n这是这个方案在 git-timemachine 中 的 完美应用.\nEvil 专用的插件介绍 # 我选择 MELPA 上最流行的5个Evil插件介绍一下, 类似优秀插件还有很多.\n要点不在于你装了多少插件, 而在于理解由于 Lisp 的强大和 Emacs 的自由, 这些插件功能更多, 更容易拓展.\nevil-surround # 对应 vim-surround.\n我通常用 expand-region 选中一段文本, 然后按 S 或者 M-x evil-surround-region , 再按任意字符 (比如双引号) 就可以在文本 首尾两端附加该字符.\n当然它也支持修改删除操作.\n之前提到的 text object 也完美支持.\n懂 Lisp 的话可以修改 evil-surround-operator-alist 自己定制操作.\nevil-nerd-commenter # 对应 vim-nerd-commenter, 这是我写的, 功能更强大.\n你可以 M-x 5 evilnc-comment-or-uncomment-lines 快速注释当前 5 行或者取消注释当前 5 行.\n你也可以选中一个区域 M-x evilnc-comment-or-uncomment-lines\n由于 Emacs 的强大, 默认就支持所有世界上已知的语言, 而核心代码也就是 1 行而已. Vim 插件对应的功能代码要有 400 行.\n如果你在 org-mode 格式的单一文件中 中混杂多种语言的话, 它也能智能识别.\n这个功能在 Vim 中基本不可能实现.\nevil-matchit # 对应 vim-matchit. 又是我写的. 自然功能更强大.\n本质就是你当前焦点在文件的某个位置 A, 你按 % 或者 M-x evilmi-jump-items, 焦点移到位置 B, 你再按同样的键, 又回到了位置 A.\n比如在一个 HTML 文件中, 你就可以在 \u0026lt;body\u0026gt; 和 \u0026lt;/body\u0026gt; 间跳来跳去. 其他各种编程语言都支持.\nVim 对应的代码我读过, 限制比较多, 比如你一定要先定义一对正则表达式来匹配 A 和 B 的位置. 这种限制在某些语言如 Python 中就会比较麻烦.\nEmacs 的实现就完全体现了 Emacs 的自由精神, 我建立了一个动态查询的矩阵, 矩阵的元素就是函数对象而已. 用户可以在运行时替换这些函数对象, 所以怎么跳转, 跳到哪都是完全自由的.\n所以 python 的支持就毫无问题. 想支持更多的语言或者对我的实现不满意, 在 .emacs 中写几行 Lisp 代码就可以了.\nevil-escape # 按自定义快捷键退出当前的各种状态, 相当于 Vim 中的 ESC 或者 Emacs 中的 C-g.\n我定义自定义快捷键为 kj. 如果你想效率高的话, 取消的默认快捷键就太慢了.\n让我给你举个例子说明什么叫效率高. 我移动手指去按 ESC 键需要 0.5 秒.\nSublime Text 默认的文本搜索要比我的 Emacs 设置慢 40 倍. 如果 Sublime Text 搜索需要 40 秒, 那么节省取消键的 0.5 秒毫无意义.\nEmacs 只要 1 秒完成搜索, 所以取消键从 0.5 秒减少到 0.1 秒的感觉就完全不一样.\nevil-visualstar # 对应 vim-visual-star-search.\n选择一段文本, 按 # 或者 * 搜索.\n在 Shell 和 Interactive Interpreter 中使用 Evil # 可以 M-x shell 或者 M-x term 进入 Shell.\n传统上大家都在 Shell 中用 Emacs 的默认快捷键.\n不过仔细计算过后我发现 Vim 的快捷键更有效率.\nShell 的作用无非就是运行命令或脚本代码, 输出运算结果.\n当我们在 Emacs 中运行 Shell 的时候, 命令和代码往往是从别的地方拷贝过来的.\n粘贴命令和代码到 Shell 中, 分析/过滤/搜索输出的结果, 都是 Vim 的快捷键更方便.\n我之前提到的所有关于 Evil 的技巧和插件都适用于此.\nInteractive Interpreter 和 Shell 没有本质区别, 无非就是解释器支持的语言不一样罢了. 比如 inf-ruby 支持 Ruby.\n可以按 C-z 切换回纯 Emacs 快捷键.\nEvil 的小结 # 对 Vim 用户来说, Evil 不仅提供了 Vim 的完美模拟, 还开辟了用 Lisp 拓展 Vim 的新世界.\n对 Emacs 用户来说, Evil 也不仅仅是提供了新的快捷键, 而是提供了更多的可编程的数据结构和范式 (如 text object).\n关键是发挥你的创造力, 自由地接合 Emacs 和 Vim 的长处, 发明新技术和新技巧. 这种机会目前是很多的, 赶快行动起来吧.\n答疑 # 新手怎么开始 # 到 https://github.com/redguardtoo/emacs.d 参考 “Install stable version in easiest way” 一节.\n只要点击下载两个 zip 文件就可以了, 不需 git 的任何知识.\n如和理解他人配置 # 除了官方文档外. 看 EmacsWiki 和源代码也很有效. 窍门是源代码文件的头部有使用指南和作者的联系方式.\n他人配置是否太重量级? # 成熟配置都是轻量级的, 因为优化过了.\n例如有种叫 Autoload 的技术. 只有用到模块的某一功能时那个模块才会被载入内存.\n其他第三方配置 # 搜 github\n也可用 我的配置：\n该使用 Emacs 的哪个版本 # 目前稳定版是 27.2. 通常不用担心版本问题. 主流的 Linux 发行版会处理.\nVi 用户要转阵营吗? # 嘿嘿, 我也是 Vi 精通后转到 Emacs 的. 就是因为 Emacs 的强大 (例如和 gdb 的完美结合) 以及其脚本语言是 Lisp.\n当然 Vi 的多模式编辑和快捷键比 Emacs 要高效得多, 所以最佳方案是 Vi + Emacs.\n目前我用 Evil, 在 Emacs 下模拟 Vim, 结合两者优点.\n现在我是 神用编辑器之神!\n为什么很多 Vi 用户不接受 Evil? # 因为他们对 Vim 快捷键做了深度配置. Emacs 默认要经常按 Ctrl 键, 如自定义的 Vim 快捷键也用 Ctrl 键, 难免有冲突.\n解决办法是大家都使 Leader (Vim 直接支持, Emacs 需 第三方插件).\n还有一个办法是待在 Vim 的舒适区里. 如能忍受没有 Org-mode 和 Lisp 的生活, 那么不会有问题.\n如犹豫不决, 请重读 “态度决定一切” 一节.\n我一旦认识到 Evil 和 Evil-leader 的潜力, 立刻把我 Vim 的设置按 Emacs 的重设了一遍。\n更光辉灿烂的例子就是Spacemacs作者了, 无数的 github 星星代表了他的成功.\n不习惯默认快捷键, 怎么办？ # 忍!\n默认快捷键经过几十年考验相当高效, 未成为高手前还是要忍.\n如一定要在用 Windows 快捷键的, 可考虑 ergoemacs.\n使用第三方配置后有些奇怪的 bug, 怎么改? # 不要改! 参考上文 站在巨人的肩膀上 一章, 你觉得奇怪是因为缺乏经验, 把某些特性误认为是 bug. 请坚持至少一年.\n例如, 有人反映右边第 80 列处总有一竖线, 希望能去掉.\n实际上这是一特性, 提醒用户一行宽度不要超过第 80 列. 这是 每行不要超过 80 列的原因.\n我建议第一年应 尽量理解而不妄加判断.\n已更新软件包, 但是没有任何作用, 也没有任何错误信息 # 删除 HOME 目录下的 .emacs, ~/.emacs.d/init.el 取代原来的 .emacs.\n有配置问题 # 读官方教程 善用网络和我提供的信息 例如, 问：在 .emacs.d 中的 init.el 文件起什么作用？ 答：搜索 “emacswiki init.el”.\n启动报错 # 先确认已装上了 你需要的 第三方命令行工具, 这些工具是可选的, 清单见 我的 README.\n如排除了以上原因, 带上 --debug-init 参数重新启动, 然后将错误信息及环境报告到对应的开发者.\n报告时应给出细节. 例如很多读者给我的 bug 都是由于第三方插件版本较新引起的, 我拿到版本号后, 才能下载特定版本以重现 bug. 否则只能靠猜, 来回邮件浪费很多时间.\n自己的简单配置好控制 # 那你就是走我后悔莫及的老路, 一个人在黑暗中摸索. 开头兴致很高, 但现实是残酷的, 碰到复杂问题解决不了. 只能逃避, 借口 Emacs 太复杂而放弃了.\n我最终醒悟过来走上光明大道, 很多走上岐路的人恐怕就没这个觉悟和毅力了.\n希望自己掌控坦率地说是一个非技术问题, 因为没有自信心, 所以有补偿心态. 希望通过一种错误的方式来证明自己. 结局无非是恶性循环.\n正确地方法是放下身段至少一年 (我已反复强调这一点), 打好基本功, 读书, 虚心学习.\n自己加的插件无效 # Emacs 是个开放平台, 其众多插件发布前并不一定有严格的测试. 所以插件之间可能有冲突.\n这也是我为什么建议初学者直接使用第三方配置配置的原因, 众多兼容性问题已解决.\n没解决的问题最好提交bug报告, 而不是自己去钻研 Lisp.\n我想用 Windows 版本的 Emacs 而不是 Cygwin 版本, 怎么做? # 需对命令行操作熟悉. 关键知识点有两个：\n设置 HOME 环境变量, 因为 .emacs.d 中的某些 Lisp 脚本假定 .emacs.d 在 HOME 所指定的路径中. Emacs 的某些功能需要使用第三方的命令行工具, 这些工具的路径应该添加至环境变量 PATH 中 (可选, 原因见后面). 如你不知道如何在 Windows 下添加修改环境变量, 不知道如何安装第三方工具, 建议还是先用 Cygwin 中的 Emacs, 因它已自带工具, 没有的话安装也方便. 且在 Cygwin 下环境变量 HOME 默认已设.\n第三方命令行工具清单请参考 我的配置中的 README.\nEmacs 在代码跳转和自动完成上和商业 IDE 有差距, 怎么办? # 现在流行 基于LSP的方案.\n我通常用 Ctags 作为后端引擎, 因其通吃所有语言. 虽然解析效果差一点, 但是恰当的命名规范 (尽量少重名) 可以弥补.\nJava 和 C# 语言的主力开发工具最好用 IDE 而不是 Emacs.\n邮件 # 我用 Gnus. 但有很多其他方案.\n如你必须访问 Microsoft Exchange Servers, 还要用 Davmail.\n用了 Davmail 后, 还可以用 Popfile 来分捡邮件. Davmail + Popfile 让我生活在天堂.\n为什么 Emacs 启动时从服务器 (elpa) 安装第三方软件包 (package) 会失败? # 请启动 Emacs 后, 运行 M-x package-refresh-contents 以从服务器更新软件索引, 然后重启 Emacs 即可.\n有些网站 Emacs 访问不了 # 在命令行中启动 Emacs 时加上 http_proxy=your-proxy-server-ip:port 前缀.\n例如,\nhttp_proxy=http://127.0.0.1:8000 emacs -nw 是否应尽早学习 Emacs Lisp # 不用,顺其自然最好.\nLisp 语法和通常的语言不同, 除非有相当编程经验 (至少 10 年), 一般人都会对其有一点负面情绪 (当然是毫无道理的偏见!). 学习任何新东西, 长期来说兴趣最重要. 一开始应避免任何负面情绪.\nEmacs Lisp 又是只用于 Emacs 的语言, 有大量术语需要掌握. 如 “Buffer”, “Yank”, “Font face”, 只有资深用户才能理解.\n所以在使用经验不足前学习软件拓展语言(Domain Specific Language)很低效.\n参考前文关于找到切入点的一节, 我推荐的顺序是, 先用优秀的配置享受到好处, 有了兴趣后学习 Lisp 就水到渠成了.\n选择适合自己的路, 一年以后天才和普通人达到的高度都是一样的.\n掌握 Emacs Lisp 是否是成为高手的必要条件? # 否. 但 Lisp 是很强大的语言, 特点是一切皆可改. 当我说 “一切” 的时候, 我就是指字面意义上的 “一切”, 不是修辞上的夸张.\n我用过许多编辑器, 除了 Emacs 没有一个能做到 “一切可改” 这点 Vim 也不行.\n学点 Lisp 对提高 Emacs 水平没坏处. 另外 Lisp 语法不错, 值得一学.\n顺便说一下, Lisp 很简单, 比 VB 容易多了, 一旦你适应其语法, 就会发觉它其实蛮友好的, 至少少打很多字.\n有必要学习键盘宏 (Keyboard Macros) 吗? # 没必要, Lisp 足够了.\n但是键盘宏生成的 Lisp 代码有时候比较有趣, 建议你精通 Lisp 后再来玩玩键盘宏.\n基本操作我会了, 下一步学什么迷茫中 # 关键是你打算用这把瑞士军刀做什么.\n前文已强调过以兴趣和解决实际问题作为切入点.\n举一些我自己的例子说明:\n我有写博客需要, 懒得用 Wordpress 那个破界面, 所以用 org2blog 开发 Ruby on Rails 程序需要 IDE, 装了 rinari 做跨平台 C++ 桌面开发, 装了 cmake-mode 需在多个子窗口间跳来跳去, 所以装了 window-numbering.el 大项目需同时调试多种语言, 所以装了 evil-nerd-commenter, 这样不用记特定语言的语法就可注释掉代码. 如何学习 org-mode? # Org-mode 简明手册 是不错的中文教程.\n最好的英文教程是 Carsten Dominik (Org-mode 发明者) 在 google tech talks 上的演讲. 其要点为 org-mode 本质是一个文本文件, 只要记住按 TAB 展开或者缩进条目就可以了. 其他特性可慢慢学.\n对于 “一切都用 Emacs 来完成” 的观点你怎么看? # 不要走火入魔. Emacs 本质是个平台, 提供了无限可能性.\n从实用角度讲, Emacs 和其他工具结合有时能更快完成工作 (不过在没有一年的修炼之前 千万不要猜 Emacs 不能做什么).\n以下是 Emacs 不一定能吃独食的地方:\n剪贴簿: 应结合命令行工具 xsel (Linux) /pbpaste (OSX) /putclip (Cygwin) Web 浏览: 用传统浏览器配合其插件 远程登录管理: 用 screen/tmux FTP: 用专门的 FTP 软件 文件管理: 用专用软件 Lisp 速度比较慢，如有大计算量的工作, 交给第三方工具来作. 重点是头脑灵活, 既坚信 Emacs 无所不能, 也适当变通.\n联系我 # 这是我的 Twitter ，博客为 http://116.62.214.11。\n我不回答具体配置的问题. 如你通读本文, 应知道哪里找答案更好。\n结语 # 再强调一下本文最重要的观点:\n以 解决实际问题 产生的兴趣引导 完全照抄世界顶尖高手如 Steve Purcell 的配置, 尽量避免自己写 Lisp 给高手报 bug 就是最好的学习, 学习 Emacs 和 学任何专业技能 (拉小提琴, 解数学题) 的方法论都是一样的, 请参考 一万小时天才理论. 关键是你以严肃的态度把其当作专业技能学习.\n很多人之所以不赞同我的核心观点, 是因为内心深处还有把 Emacs 当玩具来炫耀 “我有多酷” 的意识.\nEmacs 强大到可以作为另类娱乐来博眼球. 但本质是专业人士使用的神器.\n打个比方, 职业杀手对于刀只关心两件事:\n高效地杀人 任何环境下都可靠 刀的装饰是否漂亮或技巧是否自己原创对他并不重要.\nEmacs 就是那把刀.\n","date":"2024-06-06","externalUrl":null,"permalink":"/blog/master-emacs/","section":"Blog","summary":"如何在一年内成为Emacs高手（像熊一样使用编辑器）","title":"一年成为Emacs高手 (像熊一样使用编辑器)","type":"blog"},{"content":"","date":"2024-06-05","externalUrl":null,"permalink":"/tags/content-creation/","section":"Tags","summary":"","title":"Content Creation","type":"tags"},{"content":"============================\n为什么Lisp语言如此先进？\n一、\n如果我们把流行的编程语言，以这样的顺序排列：Java、Perl、Python、Ruby。你会发现，排在越后面的语言，越像Lisp。\nPython模仿Lisp，甚至把许多Lisp黑客认为属于设计错误的功能，也一起模仿了。至于Ruby，如果回到1975年，你声称它是一种Lisp方言，没有人会反对。\n编程语言现在的发展，不过刚刚赶上1958年Lisp语言的水平。\n二、\n1958年，John McCarthy设计了Lisp语言。我认为，当前最新潮的编程语言，只是实现了他在1958年的设想而已。\n这怎么可能呢？计算机技术的发展，不是日新月异吗？1958年的技术，怎么可能超过今天的水平呢？\n让我告诉你原因。\n这是因为John McCarthy本来没打算把Lisp设计成编程语言，至少不是我们现在意义上的编程语言。他的原意只是想做一种理论演算，用更简洁的方式定义图灵机。\n所以，为什么上个世纪50年代的编程语言，到现在还没有过时？简单说，因为这种语言本质上不是一种技术，而是数学。数学是不会过时的。你不应该把Lisp语言与50年代的硬件联系在一起，而是应该把它与快速排序（Quicksort）算法进行类比。这种算法是1960年提出的，至今仍然是最快的通用排序方法。\n三、\nFortran语言也是上个世纪50年代出现的，并且一直使用至今。它代表了语言设计的一种完全不同的方向。Lisp是无意中从纯理论发展为编程语言，而Fortran从一开始就是作为编程语言设计出来的。但是，今天我们把Lisp看成高级语言，而把Fortran看成一种相当低层次的语言。\n1956年，Fortran刚诞生的时候，叫做Fortran I，与今天的Fortran语言差别极大。Fortran I实际上是汇编语言加上数学，在某些方面，还不如今天的汇编语言强大。比如，它不支持子程序，只有分支跳转结构（branch）。\nLisp和Fortran代表了编程语言发展的两大方向。前者的基础是数学，后者的基础是硬件架构。从那时起，这两大方向一直在互相靠拢。Lisp刚设计出来的时候，就很强大，接下来的二十年，它提高了自己的运行速度。而那些所谓的主流语言，把更快的运行速度作为设计的出发点，然后再用超过四十年的时间，一步步变得更强大。\n直到今天，最高级的主流语言，也只是刚刚接近Lisp的水平。虽然已经很接近了，但还是没有Lisp那样强大。\n四、\nLisp语言诞生的时候，就包含了9种新思想。其中一些我们今天已经习以为常，另一些则刚刚在其他高级语言中出现，至今还有2种是Lisp独有的。按照被大众接受的程度，这9种思想依次是：\n1. 条件结构（即”if-then-else”结构）。现在大家都觉得这是理所当然的，但是Fortran I就没有这个结构，它只有基于底层机器指令的goto结构。\n2. 函数也是一种数据类型。在Lisp语言中，函数与整数或字符串一样，也属于数据类型的一种。它有自己的字面表示形式（literal representation），能够储存在变量中，也能当作参数传递。一种数据类型应该有的功能，它都有。\n3. 递归。Lisp是第一种支持递归函数的高级语言。\n4. 变量的动态类型。在Lisp语言中，所有变量实际上都是指针，所指向的值有类型之分，而变量本身没有。复制变量就相当于复制指针，而不是复制它们指向的数据。\n5. 垃圾回收机制。\n6. 程序由表达式（expression）组成。Lisp程序是一些表达式区块的集合，每个表达式都返回一个值。这与Fortran和大多数后来的语言都截然不同，它们的程序由表达式和语句（statement）组成。\n区分表达式和语句，在Fortran I中是很自然的，因为它不支持语句嵌套。所以，如果你需要用数学式子计算一个值，那就只有用表达式返回这个值，没有其他语法结构可用，因为否则就无法处理这个值。\n后来，新的编程语言支持区块结构（block），这种限制当然也就不存在了。但是为时已晚，表达式和语句的区分已经根深蒂固。它从Fortran扩散到Algol语言，接着又扩散到它们两者的后继语言。\n7. 符号（symbol）类型。符号实际上是一种指针，指向储存在哈希表中的字符串。所以，比较两个符号是否相等，只要看它们的指针是否一样就行了，不用逐个字符地比较。\n8. 代码使用符号和常量组成的树形表示法（notation）。\n9. 无论什么时候，整个语言都是可用的。Lisp并不真正区分读取期、编译期和运行期。你可以在读取期编译或运行代码；也可以在编译期读取或运行代码；还可以在运行期读取或者编译代码。\n在读取期运行代码，使得用户可以重新调整（reprogram）Lisp的语法；在编译期运行代码，则是Lisp宏的工作基础；在运行期编译代码，使得Lisp可以在Emacs这样的程序中，充当扩展语言（extension language）；在运行期读取代码，使得程序之间可以用S-表达式（S-expression）通信，近来XML格式的出现使得这个概念被重新”发明”出来了。\n五、\nLisp语言刚出现的时候，它的思想与其他编程语言大相径庭。后者的设计思想主要由50年代后期的硬件决定。随着时间流逝，流行的编程语言不断更新换代，语言设计思想逐渐向Lisp靠拢。\n思想1到思想5已经被广泛接受，思想6开始在主流编程语言中出现，思想7在Python语言中有所实现，不过似乎没有专用的语法。\n思想8可能是最有意思的一点。它与思想9只是由于偶然原因，才成为Lisp语言的一部分，因为它们不属于John McCarthy的原始构想，是由他的学生Steve Russell自行添加的。它们从此使得Lisp看上去很古怪，但也成为了这种语言最独一无二的特点。Lisp古怪的形式，倒不是因为它的语法很古怪，而是因为它根本没有语法，程序直接以解析树（parse tree）的形式表达出来。在其他语言中，这种形式只是经过解析在后台产生，但是Lisp直接采用它作为表达形式。它由列表构成，而列表则是Lisp的基本数据结构。\n用一门语言自己的数据结构来表达该语言，这被证明是非常强大的功能。思想8和思想9，意味着你可以写出一种能够自己编程的程序。这可能听起来很怪异，但是对于Lisp语言却是再普通不过。最常用的做法就是使用宏。\n术语”宏”在Lisp语言中，与其他语言中的意思不一样。Lisp宏无所不包，它既可能是某样表达式的缩略形式，也可能是一种新语言的编译器。如果你想真正地理解Lisp语言，或者想拓宽你的编程视野，那么你必须学习宏。\n就我所知，宏（采用Lisp语言的定义）目前仍然是Lisp独有的。一个原因是为了使用宏，你大概不得不让你的语言看上去像Lisp一样古怪。另一个可能的原因是，如果你想为自己的语言添上这种终极武器，你从此就不能声称自己发明了新语言，只能说发明了一种Lisp的新方言。\n我把这件事当作笑话说出来，但是事实就是如此。如果你创造了一种新语言，其中有car、cdr、cons、quote、cond、atom、eq这样的功能，还有一种把函数写成列表的表示方法，那么在它们的基础上，你完全可以推导出Lisp语言的所有其他部分。事实上，Lisp语言就是这样定义的，John McCarthy把语言设计成这个样子，就是为了让这种推导成为可能。\n六、\n就算Lisp确实代表了目前主流编程语言不断靠近的一个方向，这是否意味着你就应该用它编程呢？\n如果使用一种不那么强大的语言，你又会有多少损失呢？有时不采用最尖端的技术，不也是一种明智的选择吗？这么多人使用主流编程语言，这本身不也说明那些语言有可取之处吗？\n另一方面，选择哪一种编程语言，许多项目是无所谓的，反正不同的语言都能完成工作。一般来说，条件越苛刻的项目，强大的编程语言就越能发挥作用。但是，无数的项目根本没有苛刻条件的限制。大多数的编程任务，可能只要写一些很小的程序，然后用胶水语言把这些小程序连起来就行了。你可以用自己熟悉的编程语言，或者用对于特定项目来说有着最强大函数库的语言，来写这些小程序。如果你只是需要在Windows应用程序之间传递数据，使用Visual Basic照样能达到目的。\n那么，Lisp的编程优势体现在哪里呢？\n七、\n语言的编程能力越强大，写出来的程序就越短（当然不是指字符数量，而是指独立的语法单位）。\n代码的数量很重要，因为开发一个程序耗费的时间，主要取决于程序的长度。如果同一个软件，一种语言写出来的代码比另一种语言长三倍，这意味着你开发它耗费的时间也会多三倍。而且即使你多雇佣人手，也无助于减少开发时间，因为当团队规模超过某个门槛时，再增加人手只会带来净损失。Fred Brooks在他的名著《人月神话》（The Mythical Man-Month）中，描述了这种现象，我的所见所闻印证了他的说法。\n如果使用Lisp语言，能让程序变得多短？以Lisp和C的比较为例，我听到的大多数说法是C代码的长度是Lisp的7倍到10倍。但是最近，New Architect杂志上有一篇介绍ITA软件公司的文章，里面说”一行Lisp代码相当于20行C代码”，因为此文都是引用ITA总裁的话，所以我想这个数字来自ITA的编程实践。 如果真是这样，那么我们可以相信这句话。ITA的软件，不仅使用Lisp语言，还同时大量使用C和C++，所以这是他们的经验谈。\n根据上面的这个数字，如果你与ITA竞争，而且你使用C语言开发软件，那么ITA的开发速度将比你快20倍。如果你需要一年时间实现某个功能，它只需要不到三星期。反过来说，如果某个新功能，它开发了三个月，那么你需要五年才能做出来。\n你知道吗？上面的对比，还只是考虑到最好的情况。当我们只比较代码数量的时候，言下之意就是假设使用功能较弱的语言，也能开发出同样的软件。但是事实上，程序员使用某种语言能做到的事情，是有极限的。如果你想用一种低层次的语言，解决一个很难的问题，那么你将会面临各种情况极其复杂、乃至想不清楚的窘境。\n所以，当我说假定你与ITA竞争，你用五年时间做出的东西，ITA在Lisp语言的帮助下只用三个月就完成了，我指的五年还是一切顺利、没有犯错误、也没有遇到太大麻烦的五年。事实上，按照大多数公司的实际情况，计划中五年完成的项目，很可能永远都不会完成。\n我承认，上面的例子太极端。ITA似乎有一批非常聪明的黑客，而C语言又是一种很低层次的语言。但是，在一个高度竞争的市场中，即使开发速度只相差两三倍，也足以使得你永远处在落后的位置。\n附录：编程能力\n为了解释我所说的语言编程能力不一样，请考虑下面的问题。我们需要写一个函数，它能够生成累加器，即这个函数接受一个参数n，然后返回另一个函数，后者接受参数i，然后返回n增加（increment）了i后的值。\nCommon Lisp的写法如下：\n| (defun foo (n) | (lambda (i) (incf n i))) Ruby的写法几乎完全相同：\n| def foo (n) | lambda {\\|i\\| n += i } end Perl 5的写法则是：\n| sub foo { my ($n) = @\\_; | sub {$n += shift} | } 这比Lisp和Ruby的版本，有更多的语法元素，因为在Perl语言中，你不得不手工提取参数。\nSmalltalk的写法稍微比Lisp和Ruby的长一点：\n| foo: n \\|s\\| | s := n. | ^[:i\\| s := s+i. ] 因为在Smalltalk中，局部变量（lexical variable）是有效的，但是你无法给一个参数赋值，因此不得不设置了一个新变量，接受累加后的值。\nJavascript的写法也比Lisp和Ruby稍微长一点，因为Javascript依然区分语句和表达式，所以你需要明确指定return语句，来返回一个值：\n| function foo (n) { | return function (i) { | return n += i } } （实事求是地说，Perl也保留了语句和表达式的区别，但是使用了典型的Perl方式处理，使你可以省略return。）\n如果想把Lisp/Ruby/Perl/Smalltalk/Javascript的版本改成Python，你会遇到一些限制。因为Python并不完全支持局部变量，你不得不创造一种数据结构，来接受n的值。而且尽管Python确实支持函数数据类型，但是没有一种字面量的表示方式（literal representation）可以生成函数（除非函数体只有一个表达式），所以你需要创造一个命名函数，把它返回。最后的写法如下：\n| def foo (n): |　s = [n] |　def bar (i): |　s[0] += i | return s[0] | return bar Python用户完全可以合理地质疑，为什么不能写成下面这样：\n| def foo (n): | return lambda i: return n += i 或者：\n| def foo (n): | lambda i: n += i 我猜想，Python有一天会支持这样的写法。（如果你不想等到Python慢慢进化到更像Lisp，你总是可以直接……）\n在面向对象编程的语言中，你能够在有限程度上模拟一个闭包（即一个函数，通过它可以引用由包含这个函数的代码所定义的变量）。你定义一个类（class），里面有一个方法和一个属性，用于替换封闭作用域（enclosing scope）中的所有变量。这有点类似于让程序员自己做代码分析，本来这应该是由支持局部作用域的编译器完成的。如果有多个函数，同时指向相同的变量，那么这种方法就会失效，但是在这个简单的例子中，它已经足够了。\nPython高手看来也同意，这是解决这个问题的比较好的方法，写法如下：\n|　def foo (n): |　class acc: |　def _ _init_ _ (self, s): |　self.s = s |　def inc (self, i): |　self.s += i |　return self.s |　return acc (n).inc 或者\n|　class foo: |　def _ _init_ _ (self, n): |　self.n = n |　def _ _call_ _ (self, i): |　self.n += i |　return self.n 我添加这一段，原因是想避免Python爱好者说我误解这种语言。但是，在我看来，这两种写法好像都比第一个版本更复杂。你实际上就是在做同样的事，只不过划出了一个独立的区域，保存累加器函数，区别只是保存在对象的一个属性中，而不是保存在列表（list）的头（head）中。使用这些特殊的内部属性名（尤其是__call__），看上去并不像常规的解法，更像是一种破解。\n在Perl和Python的较量中，Python黑客的观点似乎是认为Python比Perl更优雅，但是这个例子表明，最终来说，编程能力决定了优雅。Perl的写法更简单（包含更少的语法元素），尽管它的语法有一点丑陋。\n其他语言怎么样？前文曾经提到过Fortran、C、C++、Java和Visual Basic，看上去使用它们，根本无法解决这个问题。Ken Anderson说，Java只能写出一个近似的解法：\n|　public interface Inttoint { |　public int call (int i); |　} | |　public static Inttoint foo (final int n) { |　return new Inttoint () { |　int s = n; |　public int call (int i) { |　s = s + i; |　return s; |　}}; |　} 这种写法不符合题目要求，因为它只对整数有效。\n当然，我说使用其他语言无法解决这个问题，这句话并不完全正确。所有这些语言都是图灵等价的，这意味着严格地说，你能使用它们之中的任何一种语言，写出任何一个程序。那么，怎样才能做到这一点呢？就这个小小的例子而言，你可以使用这些不那么强大的语言，写一个Lisp解释器就行了。\n这样做听上去好像开玩笑，但是在大型编程项目中，却不同程度地广泛存在。因此，有人把它总结出来，起名为”格林斯潘第十定律”（Greenspun’s Tenth Rule）：\n“任何C或Fortran程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是bug的、运行速度很慢的Common Lisp实现。” 如果你想解决一个困难的问题，关键不是你使用的语言是否强大，而是好几个因素同时发挥作用（a）使用一种强大的语言，（b）为这个难题写一个事实上的解释器，或者（c）你自己变成这个难题的人肉编译器。在Python的例子中，这样的处理方法已经开始出现了，我们实际上就是自己写代码，模拟出编译器实现局部变量的功能。\n这种实践不仅很普遍，而且已经制度化了。举例来说，在面向对象编程的世界中，我们大量听到”模式”（pattern）这个词，我觉得那些”模式”就是现实中的因素（c），也就是人肉编译器。 当我在自己的程序中，发现用到了模式，我觉得这就表明某个地方出错了。程序的形式，应该仅仅反映它所要解决的问题。代码中其他任何外加的形式，都是一个信号，（至少对我来说）表明我对问题的抽象还不够深，也经常提醒我，自己正在手工完成的事情，本应该写代码，通过宏的扩展自动实现。\n","date":"2024-06-05","externalUrl":null,"permalink":"/blog/why-lisp/","section":"Blog","summary":"写作即思考，不是我有什么话要说，是为了弄清楚我到底想说什么。","title":"为什么Lisp语言如此先进？","type":"blog"},{"content":"","date":"2024-05-29","externalUrl":null,"permalink":"/tags/vim/","section":"Tags","summary":"","title":"Vim","type":"tags"},{"content":"Emacs 是神的编辑器，而 Vim 是编辑器之神。二者为何会有如此美誉，且听本文向你一一道来。\n面向的读者: 经常用电脑处理文本和编程的同学 目录 # 0. 序章：神器的传说 1. 无敌的可扩展性 1.1 可扩展性给了软件强大的生命 1.2 Emacs是伪装成编辑器的操作系统 1.3 Vim不只是Vi 2. 特立独行的魅力 2.1 可扩展性让你倾注了灵魂 2.2 独特的操作方式让你中了毒 3. 黑客的编辑器 4. 神器引发的圣战 后记 0. 序章：神器的传说 # 在这个蔚蓝色的星球上，流传着两大神器的传说： 据说Emacs是神的编辑器，而Vim是编辑器之神。\n追求独步天下的高手和低手们争着一睹它们的风采，可看到它们朴素单薄的界面后，不禁心下怀疑：这就是神器吗？甚至有人生了轻视之心。\n肤浅的人嗤之以鼻，说：什么年代了，还抱着这么老土的玩意不放，真他妈Geek！同学，请冷静下来，听我说：它们的确够老了，都几十年的寿命了，但你想想为什么，为什么这么古老的编辑器，却有越来越多的人皈依它们。\nWindows下用UltraEdit和Editplus的人质问：它们到底比UltraEdit和Editplus好在哪里？我说：不可同日而语。\n连UltraEdit和EditPlus都没用过的同学问：它们就相当于Linux上的 Notepad吧？我说：请你从我的眼前消失。\n一些人勇敢地拾起了Vim或Emacs，却发现学习曲线陡峭而漫长，于是在没发现它们的强大之前就放弃了，说：太难用了，把键盘当鼠标用的烂玩意，有什么好的？\n主流编辑器学习曲线 还是有一些人留下来了，坚定地守护着这两大神器。一些说葡萄太酸的人想离开又不甘心，总是问：它们到底神在哪里啊？我不禁想起了李宗盛的几句歌词:\n有人问我你究竟是哪里好， 这么多年我还忘不掉？ 春风再美也比不上你的笑， 没见过你的人不会明了。 也许你不会明了，我还是要努力讲一讲。\n1. 无敌的可扩展性 # 1.1 可扩展性给了软件强大的生命 # 曾几何时，Windows用户对软件的可扩展性没有概念，他们只能对他们使用的软件进行非常有限的定制。扩展软件的权利保留在软件开发者手中。软件的使用者如果想要新的功能和特性，只能等待软件的升级。有能力的用户等不及了，为了添加自己想要的功能，从0开始写了一款新的软件。就这样，新的功能意味着新的软件，Windows下的软件前赴后继，迅速地更新换代着。因此，Windows下的软件都很短命。\nLinux和开源软件渐渐流行起来，人们才发现：可扩展性才能给软件强大的生命。在MS的VS横行的今天，Eclipse为什么被评为最好的IDE？就是因为它在IDE中最具可扩展性。在IE几乎一统天下的时候，为什么Firefox能夺走越来越多的用户，也是因为它的可扩展性。提供了良好的扩展接口，用户自然会写出各种各样的插件，来满足用户自己形形色色的要求。这样，软件在用户的推动下自然变得强大了。\nEmacs和Vim没有被时代淘汰，反而越发强大，也正是因为在数不清的编辑器中，他们具有无可匹敌的可扩展性。\n1.2 Emacs是伪装成编辑器的操作系统 # 有句夸张的话说：Emacs是伪装成编辑器的操作系统。细细想来，这句话并不夸张。\nEmacs其实是个Lisp的解释器，因此可以用Lisp灵活地扩展。Lisp是什么东西，这同样是种很有生命力的编程语言。在C语言还没有发明的年代，MIT的人工智能实验室写ITS操作系统时，一部分用的是汇编语言，还有一部分就是用的Lisp。现在，Lisp仍在人工智能研究领域广泛使用着。\n有这么牛逼的扩展语言，注定Emacs向着无所不能的方向发展。渐渐地，人们用Emacs不再限于写程序，写文档，而且在Emacs里管理文件系统，运行终端，收邮件，上网，听音乐……，真是一发不可收拾。甚至，有人用Emacs控制咖啡机煮咖啡。\n这种大而全的扩展，背离了“一个程序只做一件事并做好它”的Unix哲学，被Unix的忠诚用户所诟病。可是真的背离了吗？Emacs说过自己是一个编辑器吗？\n正是因为Emacs的无敌的可扩展性，人们才分不清Emacs到底是不是一个编辑器了。但，就是有人喜欢这种All-in-One的哲学，喜欢在Emacs中完成每件事。所以才会有人写《生活在Emacs中》，所以，Emacs才会成为一种信仰。\n1.3 Vim不只是Vi # Vim是Vi最受欢迎的变种之一，除了继承了Vi迅捷的编辑方式，Vim的功能已经比原始的Vi强大得多。这也得益于它可以用Vim脚本无限地扩展。 Vim.org 上已经有数千个脚本了，给Vim增加各种各样的特性和功能。\n为了证明Vim的可扩展性不输于Emacs，也有用户写了在Vim中玩游戏、运行Shell、和集成GDB在Vim内部调试的插件。客观地讲，Vim的脚本语言与Emacs的ELisp相比，略显逊色，但这丝毫不妨碍它把Vim扩展成非常优秀的编辑器。\n说到底，Vim的前身Vi和Emacs的设计采用了不同的哲学，Vi更符合Unix传统，它通过管道机制和系统内各种积木工具打交道，它讲究的是和系统内的工具程序协作来完成用户的任务。和Emacs相比，它的定位很明确，就是要做一个强大的编辑器。因此Vim的绝大部分扩展，都是为了更好地完成编辑文本的任务。\n海纳百川，有容乃大。Emacs和Vim通过别的编辑器无法比肩的可扩展性，不断吸收广大用户的智慧，是它们能成为“神器”的原因之一。\n2. 特立独行的魅力 # 2.1 可扩展性让你倾注了灵魂 # 一旦你意识到Vim或Emacs的强大，你就踏上了不停发掘它们潜力的漫漫长路。你不停地改进自己的配置文件，你不停地搜索更好的插件，甚至有一天你开始动手写自己的插件。就像剑客保养自己的剑一样，你也甘心花时间提升你的Vim或Emacs。经年累月，不知不觉，你已经在那把剑上倾注了你的灵魂。\n2.2 独特的操作方式让你中了毒 # Emacs和Vim有着迥异的操作方式，却成了Unix/Linux世界中两种代表性的操作方式，有些软件的操作方式类似Vi，而有些软件的方式类似Emacs，甚至有些软件提供了Vi的键绑定和Emacs的键绑定让你选择。而无论哪种操作方式，对Windows用户来说都是古怪的。虽说古怪，多少代人也验证了这两种操作方式的高效。\nEmacs号称Ctrl到死的编辑器。其实它几乎用了所有的辅助键，听说过没有，Emacs = Esc + Meta + Alt + Ctrl + Shift。所以高德纳大师说操作Emacs，就像弹奏管风琴。Emacs使用非常多的组合按键，这大概也是它高效于其它无模式编辑器的原因之一。你也可以定义自己的组合键序列，调用自己写的lisp函数，完成自己想要的功能。\nVi一向是以快速的文本编辑闻名于世的。它的按键更简洁，通常是单个字符按键，就实现某种操作。但这是以有模式为代价的。你要不停地按Esc在从它的插入模式返回Normal模式。客观得讲，在文本编辑方面，Vim比Emacs高效，因为它提供了一些Emacs没有对应功能的操作来辅助高效的文本编辑。但它的模式切换也让一些人受不了，于是那些人选择了Emacs。\n不管你选择了Vim还是Emacs，你都要为习惯它们独特的操作方式而努力，这是一个技艺积累的过程。当你习惯了Vim或Emacs，你会有欲罢不能的感觉，你希望用它们完成尽可能多的任务，因为你再用别的编辑器也已经不习惯。\n用Vim或Emacs就像吸食毒品，慢慢地就会上瘾。它们会带给你渐渐强烈的快感，但你也向它们献出了自己的灵魂。这时，你只能称它们为神器。\n3. 黑客的编辑器 # Vim的前身Vi的作者Bill Joy和Emacs的作者Richard Stallman都是那个时代著名的黑客，所以这两款编辑器一开始面向的主要用户就是写程序的人，现在仍然是。它们对编程加入了越来越多的支持，如语法高亮、智能缩进、关键字补全甚至集成调试。也有越来越多的程序员从IDE转向了Vim和Emacs。\n用Vim和Emacs编程到底有什么好处？我想首先是它们高效的编辑操作会提高你的编程效率。其次你可以用它们完成各种语言的编程，所谓一剑在手，夫复何求。你不用再因为编程语言不同去学习不同的IDE的使用，那些庞大的IDE的升级换代也与你再不相关，你把精力用于学习编程语言本身就好了。听说Google和微软内部开发也都不用IDE的，他们也会用Emacs或Vim。\n因为我写的程序不多，还不能深入体会用Vim或Emacs开发程序的乐趣。我只是觉得这很酷，你看，Linux之父Linus多年来用的是一款MicroEmacs，它比GNU Emacs或XEmacs少许多功能，但Linus就是用它在维护Linux。 微软的大牛Don Box，Com之父，一直用Emacs，他说谁也不能夺走他的编辑器。他还在网上放了一段他用Emacs写C#程序的视频。\n编程大师们的选择，也是Emacs和Vim被追捧为神器的原因之一。\n4. 神器引发的圣战 # Vim用户和Emacs用户有着旗鼓相当的品位，应该互相欣赏才对。现实却是，忠诚于Vim的用户和忠诚于Emacs的用户互不相容，常常没完没了地打口水仗。Emacs用户说Vim的操作方式单一而古怪，Vim用户说Emacs体积庞大，启动缓慢。\n很有点一山不容二虎的意思，大概因为二者都处于神器的高度，才会斗争不断吧。也可能是因为二者截然不同的设计哲学吸引的用户在价值观上也互不认同。\n正因为两者难分高下，新人总是在Vim和Emacs之间犹豫不定，很难决定到底要皈依哪一个神。\n后记 # Vim 称为编辑器之神，是因为作为编辑器来说，Vim 无所不能。 Emacs 称为神的编辑器，因为 Emacs 是个无所不能的编辑器。\n具体来源无法可考，这场旷日持久的编辑器之战已经打了很多年……\nEmacs 的理念是：“everything in emacs”，即所有的事情都在 emacs 里解决。你可以把emacs当作一个操作系统，“emacs lisp”是这个操作系统支持的开发语言，你可以使用emacs lisp去开发一切你需要的工具，当然，大部分常用的工具都已经有人开发完成了，并提交到了开源社区。 这么做有什么好处呢？好处就是emacs支持丰富的快捷键，只要你熟悉emacs的快捷键，那么在emacs的环境里你就不需要去动鼠标，一切一切都在瞬间的敲击键盘中完成。也就是说，emacs就是一个不需要鼠标的操作系统，这个操作系统上所有的软件都使用一套快捷键规范，熟悉这个操作系统的人，在这个操作系统里做什么都只靠敲击键盘就能够完成了，而且是瞬时的完成。 那么为什么 Emacs 被称为“神的编辑器”呢？因为这等于你需要重新学习一个非常复杂的操作系统（大脑的学习和肉体的学习），包括这个操作系统的开发语言“emacs lisp”，能精通emacs操作系统的人一般都被称为“神”。\nVi/Vim，这个名字其实不是最体切的，也许比较贴切的名字应该是： Vi/Vim/Emacs/Eclipse/Xcode/Sublime text/Firefox/Chrome/Thunderbird…..。 不要惊讶，这个名字可以变的很长，“编辑器之神”－－“编辑器之精髓”，所有遵照Vi精髓的编辑器、浏览器甚至是邮件客户端都可以放在这个长长的名字里，因为他们的键盘操作都是可以遵照Vi的按键规范的。掌握Vi就是通过掌握Vi的快捷键规范，用一致的按键方式使用不同软件。是不是有点 “葵花在手，天下我有”的感觉，但是请冷静:)。因为这种状态也不是完美的（也不可能是完美的），因为每种编辑器、浏览器都各有特色，都只是支持 Vi规范的一个子集（你总不能要求网页浏览器也能随意输入文字吧？）。不过相信我，这个子集已经可以让你的速度double再double了。\n圈内名言 # 世界上有三种程序员，一种用Emacs，一种用Vim，剩下的是用其它编辑器的。 “Emacs是神的编辑器，Vim是编辑器之神”\nEmacs是什么，Vim是什么 # 是编辑器，又不仅仅是编辑器。\nWiki Emacs： http://zh.wikipedia.org/wiki/Emacs Wiki Vim： http://zh.wikipedia.org/zh/Vim\n程序员其实很龟毛，甚至用什么编辑器他们也要纠结。跟普通的文本编辑器不同，Emacs 和 Vim 主要面向对象是程序员和技术工作者，来协助他们完成很多繁琐的工作。所以，编辑器就需要更多更强大的功能。那么，为什么不用 IDE 呢？因为 Emacs 和 Vim 有强大的定制功能，程序员可以根据自己的需要和习惯来对编辑器作出修改。\nEmacs和Vi的异同 # Emacs 和 Vim 有什么不同？答案是，很不同。 用一个词来形容 Emacs，那就是“自动化”。用一个词来形容 Vim，那就是“快”。\nEmacs 的精髓在于其配置文件。这个编辑器内置了emacs lisp的语言解释器，所有的配置都是通过这种语言来完成的。所以，要用好 Emacs，你得先学会一门语言。而 Lisp，则是计算机历史上第二个高级语言。Emacs 历史悠久，故事很多，要用好它也很不容易。能用好这么折腾的编辑器，应该也只有“神”了吧？\nVim 则完全是另一种风格。通过键盘组合，你可以很快地编辑文本。甚至你在熟练地使用 Vim 之后，你想把你的浏览器甚至是操作系统桌面按键方式也设定为 Vim 的模式。为什么？因为快！而且 Vim 显然没那么折腾，只要熟悉了基本键位之后，用不了多久你就可以指上如飞一般地coding了。Vim 是如此的简介易用而且还高效，当之无愧是编辑器之神。\n历史悠久的吐槽 # 可能是某一天，某个菜鸟coder发了一个帖子，“我是一个程序员新手，我是应该用 Vim 呢还是 Emacs 呢？”，于是，程序员圈历史悠久的优良传统之一——吐槽，又牛逼闪闪地登场了。而且程序员们的吐槽功力竟然也极为深厚，Emacser们和Vier们刚开始只是说自己的编辑器是多么多么的牛逼，然后发展到“理性批评”对方阵营的编辑器有哪些弱点。当然，一旦划分阵营，事情就起了变化。\n于是后来呢？估计是发展为某种哲学意义上的探讨了吧，不过肯定没有变为问候对方家人这种程度，又不是J2EE圈嘛（笑）。不过呢，既然被称为“编辑器之战”，这场旷日持久的争论也成为了黑客文化的一部分，为后来的程序员们津津乐道。\nHello world小组讨论编辑器的帖子： http://www.guokr.com/post/62596/ （你知道为什么要在标题前加【纯交流】三个字了吧） Editor War Wiki： http://en.wikipedia.org/wiki/Editor_war\n细节？哦，对于八卦的细节这种事，LZ还是很为难啊。因为那时候还木有LZ呢。\n同余者何人？ # 未来的种子深埋在过去之中。\n历史在发展，强大的IDE——例如Visual Studio 和 Eclipse——的出现，并没有让前辈们离开历史的舞台。Emacs 和 Vim 仍然有很多不可替代的优良特性，如果你想脱离菜鸟程序员的行列更上一层楼，那么你早晚要学会使用一个。\n用得不好也没关系，慢慢学嘛。至少可以帮你自己融入程序员圈（更为正式的说法是“社区”），当别人有.vimrc和.emacs可以晒的时候，你也能参与进去。 Hello world小组晒.vimrc的帖子： http://www.guokr.com/post/63390/\n补充一点 # Vi 里面还有跟 Emacs 作战的游戏： http://wordwarvi.sourceforge.net/\n在中国用 Vim 的人貌似比 Emacs 更多些，应该是 Vim 的中文资料多一些的缘故，而且毕竟 Vim 上手简单点； Emacs 要用顺手比 Vim 要难，组合快捷键太难记，好在有便利的 Org-Mode，Emacs 是需要自己配置的，不配置当然不能发现它的强大之处。而 Vim 默认有一千四百多个命令，不过同样的功能，用更少的击键次数。\nVim 觉得Esc键远，有个小技巧，可以用 Ctrl+[ 来代替，还可以用CapsLock替换ESC或者Left Ctrl（参考 此文）；左手小拇指可以用来回归Normal模式，真正做到双手不离键盘主行，缺点是转到用别人的电脑的时候一直写大写字母。 现在的键盘布局里CapsLock就是个废键，平常都用Shift就足够了，把CapsLock和Ctrl对换就好，无论对 Vim 还是 Emacs 来说都会好用很多。\nWhy Emacs not Vim # 虽然 Emacs 是与 Vim 齐名的强大编辑器，但事实上 Emacs 几乎具有 Vim 的所有好处，例如：\n只需要键盘就可以完成所有操作，大量使用快捷键，具有极高的编辑效率。 既可以在终端无图形界面的场景下使用，也可使用有图形界面的版本获得更现代、更美观的体验。 此外，Emacs 与其它大部分编辑器最大的不同就在于其强大的扩展性。Emacs 的内核没有对用户做出任何限制，使用 Emacs Lisp 编程语言可以为 Emacs 编写任意逻辑的插件来扩展 Emacs 的功能。经过几十年的积累，Emacs 的插件生态可谓编辑器中最为丰富和强大的生态之一。有一种说法是，“Emacs 表面上是个编辑器，其实是一个操作系统”。只要稍作学习，你也可以编写属于自己的 Emacs 扩展。 Emacs 对 Vim 用户也十分友好，有一个叫 evil 的插件可以让用户在 Emacs 中使用 Vim 的基本操作，只需要很低的迁移成本即可从 Vim 转到 Emacs （evil 或许也是最好的 Vim 模式模拟器）。曾经有统计显示有相当一部分用户会从 Vim 转到 Emacs，但几乎没有用户从 Emacs 转到 Vim。事实上，Vim 相对 Emacs 有太多目前缺失的生态（例如 org-mode），而Emacs 相对 Vim 最大的不足主要是纯文本编辑方面不如 Vim 的多模态编辑效率高，但凭借其强大的扩展性，Emacs 可以很轻易地扬长避短，把 Vim 吸收进来，从而结合二者的长处。SpaceEmacs 和 DoomEmacs 也都是开箱即用的强大解决方案。\n","date":"2024-05-29","externalUrl":null,"permalink":"/blog/why-emacs-vim-good/","section":"Blog","summary":"Emacs 是神的编辑器，而 Vim 是编辑器之神。二者为何会有如此美誉，且听本文向你一一道来。","title":"为何 Emacs 和 Vim 被称为两大神器","type":"blog"},{"content":"","date":"2023-10-07","externalUrl":null,"permalink":"/project/","section":"Projects","summary":"","title":"Projects","type":"project"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/css/","section":"Tags","summary":"","title":"Css","type":"tags"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/html/","section":"Tags","summary":"","title":"Html","type":"tags"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/javascript/","section":"Tags","summary":"","title":"Javascript","type":"tags"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/nodejs/","section":"Tags","summary":"","title":"Nodejs","type":"tags"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/react/","section":"Tags","summary":"","title":"React","type":"tags"},{"content":"","date":"2023-03-15","externalUrl":null,"permalink":"/tags/tailwind/","section":"Tags","summary":"","title":"Tailwind","type":"tags"},{"content":" HTML, CSS \u0026amp; JavaScript # 在学习前端前，需要了解一些基本的知识，比如 HTML、 CSS 和 JavaScript。我在学习这些基础时，总想着把 YouTube 上所有的教程看完，因为觉得这个教程好，那个教程也好，我如果不全都看完可能会错过一些什么。但问题是：\n这些教程有 80%相似的内容 在看完了几个教程后，我发现我还是不会写网页 于是在这里犯了第一个错误：教程地狱（Tutorial Hell）。看教程只是学习编程的第一步，看了教程学了基础，应该试着做项目来巩固理解学过的东西，而不是不停地看一个又一个教程。\n所以每个技术应该只选择一个教程并把它看完，我的选择是：\nHTML Full Course for free 🌎 (2023) CSS Full Course for free 🎨 (2023) JavaScript Full Course for free 🌐 (2023) 看完教程后，可以阅读一些完整的在线文档来查缺补漏：\nHTML - W3Schools - HTML Tutorial CSS - W3Schools - CSS Tutorial JavaScript - MDN JavaScript 但是要注意不要困于基础（Stuck In Basics），不要认为必须知道所有的基础概念后才能开始做项目。看完教程后就可以练习一些简单的项目了，阅读文档只是为了补足知识的缺漏。学习前端（或编程）应该花最少的时间看，花最多的时间做。\n完成了这些基础的学习后，可以用一些游戏测试自己对知识的掌握程度：\nCSS CSS Diner: 一个餐桌游戏，通过 CSS 选择器来选中不同的盘子或食物。 Flexbox Froggy: 练习 Flexbox 的不同属性值，让青蛙回到对应的荷叶上。 Grid Garden: 练习 Grid 的不同属性值，给胡萝卜浇水。 JavaScript JavaScript Quiz JS Robot 一些项目的推荐：\n50project50days: 每天做一个小的网呀项目一共 50 天，一共 50 个项目。比如拓展卡片，隐藏和展开搜索框等。 JavaScript30 HTML CSS JavaScript projects for beginners 2023 - 12 js projects with source code Learn JavaScript by Building 7 Games - Full Course Build 15 JavaScript Projects - Vanilla JavaScript Course CSS Framework # 到了这个阶段时，我们会发现 CSS 代码非常冗长以及难以维护，所以我们需要CSS 框架来帮助开发，简化流程。现在流行的 CSS 框架有 Bootstrap 和 Tailwind CSS。但是用 Bootstrap 写的网站大多千篇一律，Tailwind 提供了更强大的定制能力，可以写出更自定义的网站，所以我会学习Tailwind CSS。\nTailwind 有完整的文档可供学习，但是我会先看完一个 1 小时内的 Tailwind 教程再开始看文档，这样的学习心智负担会更小。\nTailwind CSS Tutorial Tailwind CSS Docs 学习 Tailwind，不需要记住所有东西，只需要对 Tailwind 有大概的了解，知道它是如何起作用的就够了。\n学完 Tailwind 基础概念后，可以练习怎么用 Tailwind 做一个 Instagram Story：\nRebuilding the Instagram Stories UI with Tailwind CSS 如果在做项目的过程中遇到了不懂或不熟悉的概念，就在 Tailwind 文档中找到它再看一次，Learn By Doing。\nJavaScript Framework # 学完 Tailwind CSS 后，可以开始学习 JavaScript 框架。现在流行的 JavaScript 框架有 React, Vue, Angular。我选择学习React。\n在学习 React 之前必须保证有坚实的 JavaScrip 基础，可以翻阅一遍 JavaScript Info再开始学习 React：\nReact Tutorial for Beginners React Docs Build Project # 在对 Tailwind 和 React 有了一定的理解后，可以用它们做一些网站克隆项目:\nReact \u0026amp; Tailwind CSS Image Gallery 🔴 Let\u0026rsquo;s build LinkedIn with REACT.JS! (with Redux \u0026amp; Firebase) React JS Crash Course for Beginners - Build 4 Apps in 12 Hours (Redux, Firebase, Auth + More) [2023] 接下来可以试着用Next.js来做项目，Next.js 是进阶版 React。\n🔴 Let\u0026rsquo;s build Facebook 2.0 with REACT.JS! (Next.js, Tailwind CSS, Image Uploading, Facebook Login) 🔴 Let\u0026rsquo;s build Hulu 2.0 with REACT.JS! (Next.js, Tailwind CSS, Responsive) Portfolio # 学了这么多技术后，我们需要一个作品集网站来展示我们的作品，作品可以是：\n日常会使用的一些流行网站的克隆 根据自己的生活需求创建的工具 谨慎地选择我们要做的项目，因为我们会回来为这些前端项目加上后端的功能。\nNode.js, Express.js \u0026amp; MongoDB # Node.js是可以在服务器上运行的 JavaScript 环境， Express.js是针对 Node.js 的框架。 MongoDB是数据库，用于存储网页上用户提供的数据。\nNode.js App From Scratch | Express, MongoDB \u0026amp; Google OAuth 因为我们从做项目中学习，如果在任何概念上卡住了，就善用搜索引擎。在工作中，任何程序员都不是所有概念都准备好了才开始做项目的。\nBring Frontend and Backend Together # 🔴 Build a Whatsapp Clone with MERN Stack (MongoDB, Express, React, Node JS) 做完这个项目后，就可以回到自己的 Portfolio 项目中，添加一些后端的功能。\n","date":"2023-03-15","externalUrl":null,"permalink":"/blog/how-i-learn-frontend/","section":"Blog","summary":"学习前端的路线与用到的资源","title":"重生之我会如何学前端","type":"blog"},{"content":"我们都玩过贪吃蛇游戏，在写出一个贪吃蛇游戏前，先复习一下游戏的玩法：\n贪吃蛇向食物格移动，用方向键控制贪吃蛇的移动方向。 每吃下一个食物格，贪吃蛇的身体会增长一格。 当贪吃蛇碰到游戏四周的边界线，或者咬到自己的身体，则游戏结束。 Live Demo: https://mia-snake-game.netlify.app/ Source Code: https://github.com/miawithcode/snake-game Prerequisite # 这篇博文假设你已经学过JavaScript中的：\nArray Object HTML Canvas DOM addEventListener() UI Events setTimeout() HTML # 写一个JavaScript程序一定会从HTML开始，写出页面的基本骨架，这里会用到HTML5的\u0026lt;canvas\u0026gt;标签：\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;gameBoard\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;500\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;div id=\u0026#34;scoreDisplay\u0026#34;\u0026gt;0\u0026lt;/div\u0026gt; \u0026lt;button id=\u0026#34;restartBtn\u0026#34;\u0026gt;Play Again\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 用gameBoard的\u0026lt;canvas\u0026gt;来定义一个宽500px，高500px的画布，用JavaScript在画布上绘制贪吃蛇与食物。 用scoreDisplay的\u0026lt;div\u0026gt;来显示当前获得的游戏分数。 用restartBtn按钮\u0026lt;button\u0026gt;重新开始游戏。 CSS # #gameBorad{ border: 3px solid; } 只有「添加画布的边框」这件事是最重要的，因为玩家需要看到贪吃蛇不能碰到的“四个墙壁”，其他元素的样式可加可不加。\nJavaScript # 第一件事，声明需要的变量。\n选中JavaScript中的元素：\nconst gameBoard = document.querySelector(\u0026#34;#gameBoard\u0026#34;); const context = gameBoard.getContext(\u0026#34;2d\u0026#34;); const scoreDisplay = document.querySelector(\u0026#34;#scoreDisplay\u0026#34;); const restartBtn = document.querySelector(\u0026#34;#restartBtn\u0026#34;); 选中\u0026lt;canvas\u0026gt;元素，创建context对象。getContext(\u0026quot;2d\u0026quot;)对象是内建的 HTML5 对象，可以绘制各种图形。 选中分数显示scoreDisplay和重启按钮restartBtn。 声明游戏画布的宽度与高度：\nconst gameWidth = gameBoard.width; const gameHeight = gameBoard.height; 声明颜色，在画布上绘制图形时使用：\nconst boardBackground = \u0026#34;#ffffff\u0026#34;; const snakeColor = \u0026#34;#53b096\u0026#34;; const snakeBorder = \u0026#34;#000000\u0026#34;; const foodColor = \u0026#34;#d44444\u0026#34;; 声明其他变量：\nconst unitSize = 25; let running = false; let score = 0; unitSize是游戏中的单位，不管是一个食物格的大小，还是贪吃蛇的一个身体部位的大小，包括贪吃蛇移动的速度，都会以unitSize为单位，这里设置为25px。 running表示游戏是否正在运行的状态。 score表示游戏的分数。 声明移动速度：\nlet xVelocity = unitSize; let yVelocity = 0; xVelocity表示每个游戏单位时间x轴移动的速度。 如果xVelocity是正数，贪吃蛇向右移动；如果是负数，贪吃蛇向左移动。 一开始设置为一个unitSize，表示向右移动一个unitSize单位。 yVelocity表示每个游戏单位时间y轴移动的速度。 如果yVelocity是正数，贪吃蛇向下移动；如果是负数，贪吃蛇向上移动。 一开始设置为0，表示开始时即不向上移动也不向下移动。 声明食物格的坐标变量：\nlet foodX; let foodY; foodX是食物格在画布中的x坐标。 foodY是食物格在画布中的y坐标。 食物格的坐标会用函数createFood()随机生成。 声明一个对象数组表示贪吃蛇：\nlet snake = [ {x:unisize * 4, y:0}, {x:unisize * 3, y:0}, {x:unisize * 2, y:0}, {x:unisize, y:0}, {x:0 y:0}, ] 定义初始贪吃蛇的长度是5格。 每个对象中的属性是贪吃蛇身体每个部分在画布中的x坐标和y坐标。 声明完变量后，我们给windows窗口添加addEventListner监听键盘事件，监听←↓↑→方向键是否被按下。如果监听到方向键被按下，则执行changeDirection()函数改变贪吃蛇移动的方向，这个函数会在稍后被定义。\nwindow.addEventListener(\u0026#34;keydown\u0026#34;, changeDirection); 给restartBtn按钮添加addEventListener监听鼠标事件，当按钮被点击时，执行restartGame()函数，在稍后也会被定义。\nrestartBtn.addEventListener(\u0026#34;click\u0026#34;, restartGame); 调用开始游戏的函数startGame()，稍后定义。\nstartGame(); 解下来定义我们所有需要的函数。\nThe startGame function # function startGame(){ running = true; scoreDisplay.textContent = score; createFood(); drawFood(); nextTick(); } 设置运行状态running为true，表示游戏开始。 将页面上的游戏分数更改为当前获得的游戏分数。 依次调用createFood()和drawFood()和nextTick()函数。 The nextTick function # nextTick()是每个游戏时间单位都会做的事情。\nfunction nextTick(){ if(running){ setTimeout(() =\u0026gt;{ clearBoard(); drawFood(); moveSnake(); drawSnake(); checkGameOver(); nextTick(); }, 75) } else{ displayGameOver(); } } 如果游戏正在进行，设置75毫秒后会做的事情：清除画布，绘制食物格，移动贪吃蛇，绘制贪吃蛇，检查游戏是否结束，再调用一次nextTick()函数，这样就能不断重复这些过程，并在游戏结束时停下。 如果游戏停止，则在页面上提醒游戏结束。 The clearBoard function # clearBoard()函数用于重画画布。\nfunction clearBoard(){ context.fillStyle = boardBackground; context.fillRect(0, 0, gameWidth, gameHeight); } fillStyle设置画布的填充颜色。 fillRect(x,y,width,height)绘制一个画布，从坐标（0,0)开始，宽度和高度都是画布的宽度和高度。 The creatFood function # createFood会随机在画布中找到一个位置放置食物格。\nfunction createFood(){ function randomFood(min, max){ const randNum = Math.round((Math.random() * (max - min) + min) / unitSize) * unitSize; return randNum; } foodX = randomFood(0, gameWidth - unitSize); foodY = randomFood(0, gameWidth - unitSize); } 定义一个内嵌函数randomFood生成能被unitSize整除的随机数。 (Math.random() * (max - min) + min)会生成在min到max之间的随机数； 这个Math.round()取得这个随机数除以unitSize的整数，得到这个随机数一共有多少个UnitSize； 此时再乘以UnitSize，就会得到范围在min~max之间，并且无论如何都会被unitSize整除的随机数。 食物格x轴的范围是0～gameWidth - unitSize，y轴也一样。 分别随机生成食物格x轴的值与y轴的值，得到食物格的位置。 The drawFood function # drawFood会在游戏画布中绘制出食物格。\nfunction drawFood(){ context.fillStyle = foodColor; context.fillRect(foodX, foodY, unitSize, unitSize); } fillStyle设置图形的填充颜色。 fillRect(x,y,width,height)绘制一个方形，食物格的x轴与y轴，在createFood()函数中已经随机生成，食物格的宽度和高度都会是一个unitSize。 The moveSnake function # 移动贪吃蛇的思路是：在贪吃蛇的移动方向创建一个贪新的头部方块，并消除尾巴方块，这样看起来就像在移动一样。\nfunction moveSnake(){ const head = {x: snake[0].x + xVelocity, y: snake[0].y + yVelocity}; snake.unshift(head); if(snake[0].x == foodX \u0026amp;\u0026amp; snake[0].y == foodY){ score++; scoreDisplay.textContent = score; createFood(); } else{ snake.pop(); } } 创建一个新的头部方块并用Array.unshift()方法向数组的开头添加该头部。 判断贪吃蛇是否吃掉了食物格，如果贪吃蛇头部的坐标和食物格的坐标重合，那么就是吃掉了食物格。此时将游戏分数加1，并再创建一个食物。 如果没有吃掉食物格，那么贪吃蛇在移动，用Array.pop()会删除数组的最后一个元素，在这里，就是删除贪吃蛇的尾巴方块。 The drawSnake function # function drawSnake(){ context.fillStyle = snakeColor; context.strokeStyle = snakeBorder; snake.forEach(snakePart =\u0026gt; { context.fillRect(snakePart.x, snakePart.y, unitSize, unitSize); context.strokeRect(snakePart.x, snakePart.y, unitSize, unitSize); }) } 因为snake是一个数组对象，用forEach遍历贪吃蛇的每一个身体部位，并画出方块与边框。 The changeDirection function # function changeDirection(event){ const keyPressed = event.keyCode; const LEFT = 37; const UP = 38; const RIGHT = 39; const DOWN = 40; const goingUp = (yVelocity == -unitSize); const goingDown = (yVelocity == unitSize); const goingRight = (xVelocity == unitSize); const goingLeft = (xVelocity == -unitSize); switch(true){ case (keyPressed == LEFT \u0026amp;\u0026amp; !goingRight): xVelocity = -unitSize; yVelocity = 0; break; case (keyPressed == UP \u0026amp;\u0026amp; !goingDown): xVelocity = 0; yVelocity = -unitSize; break; case (keyPressed == RIGHT \u0026amp;\u0026amp; !goingLeft): xVelocity = unitSize; yVelocity = 0; break; case (keyPressed == DOWN \u0026amp;\u0026amp; !goinUp): xVelocity = 0; yVelocity = unitSize; break; } } keyCode表示键盘上的按键键的键码值，keyPressed存储当前按下的按键的键码值。方向键的键码值分别是： ←: 37 ↑: 38 →: 39 ↓: 40 用描述性的语言LEFT、UP、RIGHT、DOWN存储这些键码值。 goingUp、goingDown、goingRight、goingLeft返回的是布尔值。 判断keyPressed == LEFT \u0026amp;\u0026amp; !goingRight的目的是保证按下左方向键←后，可以继续向左向上或向下，当不能向右，因为向右将咬到自己输掉游戏。 The checkGameOver function # 游戏结束有两种情况，一种情况是，贪吃蛇碰到游戏的边框，第二种情况是贪吃蛇咬到自己。\nfunction checkGameOver(){ switch(true){ case (snake[0].x \u0026lt; 0): running = false; break; case (snake[0].x \u0026gt;= gameWidth): running = false; break; case (snake[0].y \u0026lt; 0): running = false; break; case (snake[0].y \u0026gt;= gameHeight): running = false; break; } for(let i = 1; i \u0026lt; snake.length; i++){ if(snake[i].x == snake[0].x \u0026amp;\u0026amp; snake[i].y == snake[0].y){ running = false; } } } 用switch条件语句判断是否碰到游戏画布的边框： 当贪吃蛇头部的x坐标小于0，说明贪吃蛇碰到了左边的边框，结束游戏。 当贪吃蛇头部的x坐标大于画布的宽度，说明贪吃蛇碰到了右边的边框，结束游戏。 当贪吃蛇头部的y坐标小于0，说明贪吃蛇碰到了上面的边框，结束游戏。 当贪吃蛇头部的y坐标大于画布的高度，说明贪吃蛇碰到了下面的边框，结束游戏。 用for循环遍历贪吃蛇身体的每个部分，判断贪吃蛇的头部是否与身体的任何一个部分重合。 The display GameOver function # 在游戏的中间显示“GAME OVER!”\nfunction displayGameOver(){ context.font = \u0026#34;50px Shantell Sans\u0026#34;; context.fillStyle = \u0026#34;black\u0026#34;; context.textAlign = \u0026#34;center\u0026#34;; context.fillText(\u0026#34;GAME OVER!\u0026#34;, gameWidth / 2, gameHeight /2); running = false; } The restartGame function # function restartGame(){ score = 0; xVelocity = unitSize; yVelocity = 0; snake = [ {x:unitSize * 4, y:0}, {x:unitSize * 3, y:0}, {x:unitSize * 2, y:0}, {x:unitSize, y:0}, {x:0, y:0}, ]; startGame(); } 将游戏分数和移动速度重置为0。 重新创建一个snake。 调用开始游戏startGame()函数。 到此为止，已经成功写出基本的贪吃蛇游戏了。\n结语 # 发现贪吃蛇能很好的练习HTML5的Canvas，和JavaScript的DOM与事件，值得反复练习。\nReference # A game of Snake written in JavaScript 🐍 ","date":"2023-03-08","externalUrl":null,"permalink":"/project/how-to-build-a-snake-game-in-javascript/","section":"Projects","summary":"JavaScript的练习项目，实现贪吃蛇游戏。","title":"如何用JavaScript实现贪吃蛇游戏","type":"project"},{"content":"在这篇文章中会展示如何用JavaScript实现一个秒表计时器，这是我在学习JavaScript过程中的一个练习项目，接下来的内容也只是我作为初学者在练习过程中的理解。\n在一个秒表计时器(stop watch)中会有开始计时，暂停计时，与重置时间的功能，同时，我们希望在暂停计时后，还能从当前位置继续计时，接下来将实现这些功能。\nLive Demo: https://mia-stop-watch.netlify.app/ Source Code: https://github.com/miawithcode/stop-watch Prerequisite # 这篇博文假设你已经学过JavaScript中的：\nDate Object DOM Arrow Function（箭头函数） Callback （回调函数） addEventListener() setInterval() \u0026amp; setTimeout() Math.floor() Date.now() # 在开始写代码前，先了解Date Object中的Date.now()方法。\nDate.now()是写在JavaScript内嵌对象Date中的方法，表示从纪元时间(UTC 1970/01/01)到现在经过的时间，返回以毫秒为单位的值。\n比如在写这篇文章的当下，Date.now()返回的值是：1677832655179，意味着从1970/01/01到现在一共流逝了1677832655179毫秒。\n下面是一个简单的例子：\nconst startTime = Date.now(); console.log(\u0026#34;开始计时\u0026#34;); setTimeout(() =\u0026gt; { const elapsedTime = Date.now() - startTime; elapsedTime = Math.floor(elapsedTime / 1000); console.log(`结束计时，用时： ${elapsedTime}`s, 2000) }) //Expected output: 结束计时，用时：2s 我们把【打印「开始计时」的时间】赋值给变量startTime，然后打印出“开始计时”。 用setTimeout()方法设置2秒后打印「结束计时」语句，同时打印出两条打印语句的间隔时间elapsedTime。 间隔时间elapsedTime等于【当前打印「结束计时」时的时间 Date.now()】减去【打印「开始计时」时的时间 startTime】 间隔时间elapsedTime应该为2s，因为setTimeout()设置的时间是2s。 理解了这个例子之后，我们会用这个·Date.now()方法表示计时器中涉及的时间。\nHTML # 我们从HTML开始，写出计时器中基本的文本与按钮。\n\u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;h1 id=\u0026#34;timeDisplay\u0026#34;\u0026gt;00:00:00:00\u0026lt;/h1\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;startBtn\u0026#34;\u0026gt;Start\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;pauseBtn\u0026#34;\u0026gt;Pause\u0026lt;/button\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; id=\u0026#34;resetBtn\u0026#34;\u0026gt;Reset\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 使用了一些非常基础的HTML标签：\n用一级标题\u0026lt;h1\u0026gt;来显示页面上的时间：00:00:00:00 用三个按钮\u0026lt;button\u0026gt;分别用于start（开始计时），pause（暂停计时），reset（重置时间）。 目前我们不关心CSS样式，只关心计时器的实现，你可以按照自己的喜好设计计时器，接下来用JavaScript实现计时器的功能。\nJavaScript # 首先，声明我们需要的变量：\nconst timeDisplay = document.querySelector(\u0026#34;#timeDisplay\u0026#34;); const startBtn = document.querySelector(\u0026#34;#startBtn\u0026#34;); const pauseBtn = document.querySelector(\u0026#34;#pauseBtn\u0026#34;); const resetBtn = document.querySelector(\u0026#34;#resetBtn\u0026#34;); let startTime = 0; let elapsedTime = 0; let paused = true; let intervallId; let hours = 0; let minutes = 0; let seconds = 0; let miliseconds = 0; document.querySelector选择的是4个HTML中的元素（Element），一级标题和三个按钮。 startTime与elapsedTime分别表示开始时间与间隔时间。 开始时间startTime有两种，一种是从 00:00:00:00 开始计时的时间，另一种是暂停后继续计时的开始时间。 间隔时间elapsedTime也有两种，一种是setInterval()设置的间隔时间，另一种是暂停后继续计时中暂停了多久的间隔时间。 paused是一个布尔值，用于判断当前程序是暂停了，还是正在运行。在一开始时，把paused设置成false。 intervalId是setInterval()这个timer的id，一开始只声明不赋值。 hours, minutes, seconds, miliseconds分别代表 00:00:00:00 中各自的单位。 The start button # 然后我们实现开始计时的功能：\nstartBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { if(paused){ paused = false; startTime = Date.now() - elapsedTime; intervalId = setInterval(updateTime, 75); } }) 给开始计时的按钮startBtn添加点击事件，设置点击开始计时的按钮后会执行的程序。 检查暂停状态paused是否为true，如果程序是暂停的，则将暂停状态paused设置成false，表示计时器是开启的状态。 开始计时的时间startTime会等于现在的时间Date.now()减去间隔时间elapsedTime 因为接下来会用setInterval设置一个重复定时调用的函数，比如每隔1000毫秒调用一次函数，此时的1000毫秒就是elapsedTime。 最开始的elapsedTime我们在声明变量时已经设置成0; 用setInterval()设置每隔75毫秒调用一次updateTime()函数。 The updateTime function # 接下来定义updateTime()函数：\n我们先看最基础的逻辑，updateTime()到底要实现什么：\nfunction updateTime(){ elapsedTime = Date.now() - startTime; miliseconds = Math.floor(elapsedTime % 1000); seconds = Math.floor(elapsedTime / 1000 % 60); minutes = Math.floor(elapsedTime / 1000 / 60 % 60); hours = Math.floor(elapsedTime / 1000 / 60 / 60 % 60); timeDisplay.textContent = `${hours}:${minutes}:${seconds}:${miliseconds}`; } 间隔时间elapsedTime等于现在的时间Date.now()减去开始计时的时间startTime。而这个间隔时间就是我们显示在页面上的时间。 举个例子，我从8:30开始计时，现在的时间是8:35，一共过去了5分钟，那么现在计时器上的时间就应该是5分钟。 由于Date.now()返回的是以毫秒为单位的值，那么计算出的间隔时间elapsedTime的单位也是毫秒数，我们要把它格式化成00:00:00:00的形式 由于1000毫秒等于1秒，那么每过1000毫秒，秒数就会增加1秒，而毫秒位会归零重新计数，所以用变量miliseconds等于elapsedTime取余%1000的值。秒数，分钟数，时钟数也是这个思路去格式化。 将格式化后的elapsedTime显示在HTML页面上。但是此时会有一个问题：在显示时，秒数、分钟数、时钟数有1位数和2位数的情况，我们希望当它们是1位数时，前面会有1个0来组成2位数。 我们在updateTime()函数中写一个内嵌函数formatTime()，当秒数、分钟数、时钟数是1位数时，在前面添加一个0：\nfunction formatTime(unit){ return ((\u0026#34;0\u0026#34;) + unit).length \u0026gt; 2 ? unit : \u0026#34;0\u0026#34; + unit; } formatTime()函数接受一个时间单位作为参数， 判断当\u0026quot;0\u0026quot;加上一个时间单位时，这个时间单位的字符串长度是否大于2。 如果\u0026quot;0\u0026quot; + unit的字符串长度大于2，说明这是一个2位数的时间单位，只需要返回这个时间单位； 如果\u0026quot;0\u0026quot; + unit的字符串小于2，说明这是一个1位数的时间单位，返回\u0026quot;0\u0026quot; + unit。 在formateTime()我们没有考虑miliseconds的情况，因为它最多可以有3位数，我们用一个formatMili()来单独实现毫秒的格式化：\nfunction formatMili(unit){ unit = String(unit); switch(unit.length){ case 1: return \u0026#34;0\u0026#34; + unit; break; case 2: return unit; break; case 3: return unit.slice(0, 2); break; } } 首先将数字类型的miliseconds类型转化为字符串类型，这样才能用String.length来判断毫秒数是几位数。 用switch条件语句分别判断当毫秒数是1位数、2位数、3位数时的情况。 完整的updateTime()函数的代码是：\nfunction updateTime(){ elapsedTime = Date.now() - startTime; miliseconds = Math.floor(elapsedTime % 1000); seconds = Math.floor(elapsedTime / 1000 % 60); minutes = Math.floor(elapsedTime / 1000 / 60 % 60); hours = Math.floor(elapsedTime / 1000 / 60 / 60 % 60); miliseconds = formatMili(miliseconds); seconds = formatTime(seconds); minutes = formatTime(minutes); hours = formatTime(hours); timeDisplay.textContent = `${hours}:${minutes}:${seconds}`; function formatTime(unit){ return ((\u0026#34;0\u0026#34;) + unit).length \u0026gt; 2 ? unit : \u0026#34;0\u0026#34; + unit; } function formatMili(unit){ unit = String(unit); switch(unit.length){ case 1: return \u0026#34;0\u0026#34; + unit; break; case 2: return unit; break; case 3: return unit.slice(0, 2); break; } } } The pause button # pauseBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { if(!paused){ paused = true; elapsedTime = Date.now() - startTime; clearInterval(intervalId); } }) 给暂停计时的按钮添加点击事件，设置点击暂停计时的按钮后会执行的程序。 检查现在是否不是处于暂停状态，即是否是正在计时的状态，如果是，则将paused设置成true，表示现在是暂停状态。 计算暂停了多长时间eplasedTime 调用clearInterval终止setInterval()设置的重复定时任务，即停止更新页面上的时间。 The reset button # 重置时间是一个比较简单的功能，重置就是把所有状态恢复到最开始的状态。\nresetBtn.addEventListener(\u0026#34;click\u0026#34;, () =\u0026gt; { paused = true; clearInterval(intervalId); startTime = 0; elapsedTime = 0; hours = 0; minutes = 0; seconds = 0; miliseconds = 0; timeDisplay.textContent = \u0026#34;00:00:00:00\u0026#34;; }) 把暂停状态paused设置成true，因为现在没有在计时。 调用clearInterval终止setInterval()设置的重复定时任务，即停止更新页面上的时间。 把所有变量重新设置为0 将HTML的文本重新设置为00:00:00:00 到此为止，一个秒表计时器的功能已经全部实现。\n结语 # 这个project我在学习的时候有很多地方卡壳想不明白，写完这篇博文后发现思路其实非常清晰，看来「The best way of learning is teaching.」is so damn true\nReference # Date.now()的解释 - Mozilla A stopwatch written in JavaScript ⏱️ ","date":"2023-03-07","externalUrl":null,"permalink":"/project/how-to-build-a-stop-watch-in-javascript/","section":"Projects","summary":"JavaScript的练习项目，实现开始计时，暂停计时，和重置时间的功能。","title":"如何用JavaScript实现秒表计时器","type":"project"},{"content":" ","date":"2023-02-05","externalUrl":null,"permalink":"/booknote/","section":"Book Note","summary":" ","title":"Book Note","type":"booknote"},{"content":"","date":"2022-10-18","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github Pages","type":"tags"},{"content":"","date":"2022-10-18","externalUrl":null,"permalink":"/tags/tutorial/","section":"Tags","summary":"","title":"Tutorial","type":"tags"},{"content":"根据 GitHub Pages 官网介绍，一个GitHub账号只能拥有一个 GitHub Pages 网站，但该账号可以拥有无限的项目 GitHub Pages 网站。当仓库中已经有一个\u0026lt;username\u0026gt;.github.io时，要如何为项目创建 GitHub Pages？\n答案是：在项目仓库中建立gh-pages分支。\n1. 在本地创建空的 gh-pages 分支 # 以Hugo建站为例，Hugo生成的所有 html 文件会储存在 public 文件夹中，所以只需将 public 文件夹中的内容上传至 gh-pages 分支并部署。\n# 进入要上传的文件夹 cd public # 将文件夹初始化为 git 仓库，设置主分支为 main git init -b main #创建 gh-pages 分支，并切换到 gh-pages 分支 git checkout --orphan gh-pages 2. 推送 public 文件中的内容至 gh-pages # #将文件提交到暂存区并提交 git 修改信息 git add . git commit -m \u0026#34;...（信息）\u0026#34; #连接远程仓库(仓库的 SSH 链接) git remote add origin git@github.com:username/repository.git #将 `public` 文件夹中的内容推送至远程仓库 git push origin gh-pages 3. 部署项目至 gh-pages 分支 # 做完这一步就大功告成了，如果你没有为项目设置自定义域名，接下来可以在 https://\u0026lt;username\u0026gt;/repository.github.io 看到刚刚部署的项目内容。\nReference # GitHub Pages 官网 在github上建立gh-pages分支 Related Posts # 如何用 GitHub Pages + Hugo 搭建个人博客 ","date":"2022-10-18","externalUrl":null,"permalink":"/blog/deploy-project-to-gh-pages/","section":"Blog","summary":"介绍当仓库中已经有一个 \u003ccode\u003e\u0026lt;username\u0026gt;.github.io\u003c/code\u003e 仓库时，如何创建\u003ccode\u003egh-pages\u003c/code\u003e分支来为项目设置 GitHub Pages。","title":"如何给项目设置 GitHub Pages","type":"blog"},{"content":"","date":"2022-08-29","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":" 1. 概念，搭建思路和运行环境 # 1.1 什么是 GitHub Pages？ # GitHub Pages 是一组静态网页集合（Static Web Page），这些静态网页由 GitHub 托管（host）和发布，所以是 GitHub + Pages。\n1.2 什么是 Hugo？ # Hugo 是用 Go 语言写的静态网站生成器（Static Site Generator）。可以把 Markdown 文件转化成 HTML 文件。\n1.3 网站搭建思路 # 创建 2 个 GitHub 仓库 博客源仓库：储存所有 Markdown 源文件（博客内容），和博客中用到的图片等。 GitHub Pages 仓库：储存由 Hugo 从Markdown 文件生成的 HTML 文件。 将在博客源仓库中 Hugo 生成的静态 HTML 文件部署到远端 GitHub Pages 仓库中。 1.4 运行环境 # 这篇教程假设你已经：\n了解基本的终端命令行知识，如：cd, ls 安装了 Git，并且了解基本的 Git 知识 有一个 \u0026lt; icon \u0026ldquo;github\u0026rdquo; \u0026gt;}} GitHub账号 有自己偏好的代码编辑器（我使用的是 VS Code） 2. 安装 Hugo # 这里使用包管理器安装 Hugo，我的操作系统是 Mac OS，所以使用 Homebrew 安装 Hugo。如果你使用的是 Windows 或 Linux，可以根据 Hugo 文档提示的方式安装： Hugo 文档：Install Hugo\nbrew install hugo 查看 Hugo 是否安装成功，显示 Hugo 版本号代表 Hugo 安装成功。\nhugo version 3. 创建 GitHub 仓库 # 3.1 创建博客源仓库 # 命名博客源仓库（whatever you want） \u0026lt; icon \u0026ldquo;check\u0026rdquo; \u0026gt;}}勾选 Public，设置为公开仓库。 \u0026lt; icon \u0026ldquo;check\u0026rdquo; \u0026gt;}}勾选添加 README 文件 3.2 创建 GitHub Page 仓库 # 命名 GitHub Pages 仓库，这个仓库必须使用特殊的命名格式 \u0026lt;username.github.io\u0026gt;， \u0026lt;username\u0026gt; 是自己的 GitHub 的用户名。 \u0026lt; icon \u0026ldquo;check\u0026rdquo; \u0026gt;勾选 Public，设置为公开仓库。 \u0026lt; icon \u0026ldquo;check\u0026rdquo; \u0026gt;勾选添加 README 文件，这会设置 main 分支为仓库的默认主分支，这在后面提交推送博客内容时很重要。 4. 克隆博客源仓库到本地 # 打开想要在本地储存项目的文件夹（比如我的项目的文件夹是 project ）\ncd project 克隆博客源仓库到项目文件夹，克隆时使用的 HTTPS 仓库链接在这里查看： git clone https://github.com/miawithcode/cuttontail.git 5. 使用 Hugo 创建网站 # 进入刚刚克隆下来的博客源仓库文件夹（比如：我的博客源仓库文件夹名是 cuttontail，则cd cuttontail ），在这个文件夹里用 Hugo 创建一个网站文件夹。\n用 Hugo 创建网站文件夹的命令是 hugo new site 网站名字。(比如，我的命名是 cuttontail-blog)\ncd cuttontail hugo new site cuttontail-blog 用 Hugo 创建的网站共有 7 个文件夹和 1 个文件，这些文件分别代表： archetypes：存放用 hugo 命令新建的 Markdown 文件应用的 front matter 模版 content：存放内容页面，比如「博客」、「读书笔记」等 layouts：存放定义网站的样式，写在layouts文件下的样式会覆盖安装的主题中的 layouts文件同名的样式 static：存放所有静态文件，如图片 data：存放创建站点时 Hugo 使用的其他数据 public：存放 Hugo 生成的静态网页 themes：存放主题文件 config.toml：网站配置文件 6. 安装和配置 Hugo 主题 # 6.1 选择 Hugo 主题 # 可以从 Hugo 社区提供的主题中选择一个喜欢的主题应用在自己的网站中。\n6.2 安装 Hugo 主题 # 一般在你选择的 Hugo 主题的文档中，都会给出「如何安装这个主题」的命令，比如我选用的 Hugo Bear Blog 的文档中给出：\n打开刚刚用 Hugo 创建的网站文件夹（我的是 cuttontail-blog），在终端粘贴文档中给出的安装命令。 这时可以看到在themes文件夹中，多出了刚刚安装的主题文件，代表主题安装成功。 6.3 配置 Hugo 主题 # 一般安装的 Hugo 主题的文件结构中都会有 exampleSite 文件夹，也是你在选择主题时参考的网站 demo。\n把 exampleSite 的文件复制到站点目录，在此基础上进行基础配置。 非常推荐这么做，这样做能解决很多「为什么明明跟教程一步一步做下来，显示的结果却不一样？」的疑惑。（这主要是因为不同的主题模版配置文件不同导致的。）\n在把exampleSite文件复制到站点目录时，请根据对应文件夹进行复制文件\n比如exampleSite下有 content , static 和 config.toml 3 个文件，就找到你自己的站点跟目录下这对应的三个文件。在把对应目录中的内容分别复制过去。 其中在复制config.toml的内容时要注意：\nbaseURL baseURL = \u0026#34;https://example.com/\u0026#34; #把https://example.com/改成自己的域名 如果你没有在 GitHub Pages 中设置自定义域名，这里的域名应该填 https://\u0026lt;username\u0026gt;.github.io/ （⚠️ 注意：最后的/不要忘了加） themes themes = \u0026#34;你选择的主题名字\u0026#34;。 #这一行命令代表启用你安装的主题 在 config.toml 中输入这行命令才能启用安装的主题，不过一般这行命令在你复制 exampleSite 的配置文件信息时，主题作者已经写好了这行。 7. 用 Hugo 创建文章 # 用 Hugo 创建一篇文章的命令是:\nhugo new xxx.md 用这个命令创建的 Markdown 文件会套用 archetypes 文件夹中的 front matter 模版，在空白处用 Markdown 写入内容。 其中，draft: true代表这篇文章是一个草稿，Hugo 不会显示草稿，要在主页显示添加的文章，可以设置 draft: false；或者直接删掉这行。\n8. 本地调试和预览 # 在发布到网站前可以在本地预览网站或内容的效果，运行命令： hugo server 也可以在本地编辑 Markdown 文件时，通过 hugo server 来实时预览显示效果。 hugo server 运行成功后，可以在 http://localhost:1313/ 中预览网站 9. 发布内容 # hugo 命令可以将你写的 Markdown 文件生成静态 HTML 网页，生成的 HTML 文件默认存放在 public 文件夹中。\nhugo 因为hugo 生成的静态 HTML 网页文件默认存放在 public 文件中，所以推送网页内容只需要把 public 中的 HTML 网页文件发布到 GitHub Pages 仓库中。\n将 public 文件夹初始化为 Git 仓库，并设置默认主分支名为 main。这么做的原因是：\nGitHub 创建仓库时生成的默认主分支名是 main 用 git init 初始化 Git 仓库时创建的默认主分支名是 master 将 git init 创建的 master 修改成 main ，再推送给远端仓库 \u0026lt;username\u0026gt;.github.io ，这样才不会报错。 cd public git init -b main 将 public 文件夹关联远程 GitHub Pages 仓库，使用 GitHub Pages 仓库的 SSH 链接。\n（ ⚠️ 注意：要让 SSH 链接起作用，需要你添加过 SSH Key。如果你没有设置过 SSH Key，请参考 如何在 Mac 上为 GitHub 设置 SSH Key）\nGitHub Pages 仓库的 SSH 链接可以在这里查看： git remote add origin git@github.com:miawithcode/miawithcode.github.io.git 推送博客源仓库的 public 文件夹中的 HTML 网页文件到 GitHub Pages 仓库 中，在推送仓库内容前要先用 git pull --rebase origin main 和远端仓库同步，否则会报错。\ngit pull --rebase origin main git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push origin main 转到 GitHub 查看 GitHub Pages 仓库中是否存在刚刚推送的文件，存在则代表推送成功。 如果你没有设置自定义域名，且把 comfig.toml 文件中的 baseURL 设置为 https://\u0026lt;username\u0026gt;.github.io，就可以在 https://username.github.io 中查看刚刚创建的网站。 ( 👀 我使用的是自定义域名，所以这里用我的自定义域名查看。) 后续的更新步骤：\n创建你的文章xxx.md 用 hugo server 在本地预览，满意后准备发布。 运行 hugo 命令将 Markdown 文件生成 HTML 文件。 将修改先提交至博客源仓库 git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git push 打开 public 文件 运行： git add . git commit -m \u0026#34;...(修改的信息)\u0026#34; git pull --rebase origin main #可选,如果远端仓库与本地一致，则不需要合并。 git push origin main 如果你使用的是自定义域名，第一次推送成功后，GitHub Pages 仓库会生成 CNAME 文件，所以第二次推送还要再合并一次：git pull --rebase origin main。后续更新博客就不再需要使用这个命令了。（根据实际情况使用） 发布内容除了手动发布，还能使用 GitHub Action 自动发布。但我认为刚刚搭建好一个网站，立刻就用 GitHub Action 有些 Overwhelming，先学会手动发布，熟练之后再开始使用 GitHub Action 自动发布会比较好。\n10. Reference # Creating a Blog with Hugo and Github in 10 minutes Hugo + GitHub Action，搭建你的博客自动发布系统 Hugo - Quick Start ","date":"2022-08-29","externalUrl":null,"permalink":"/blog/create-a-wesite-using-github-pages-and-hugo/","section":"Blog","summary":"介绍如何使用一个博客源仓库和一个GitHub Pages仓库，使用 GitHub Pages 和 Hugo 搭建个人博客。","title":"如何用 GitHub Pages + Hugo 搭建个人博客","type":"blog"},{"content":"Now 页面会随着时间和当下生活的优先级而更新，用来让别人看见这个人现在生活的重点是什么，和提醒自己专注于当下最重要的事。\n正在做 # 通过 JavaScript Info 复习 JavaScript 学习 Tailwind 学习 React 正在读 # 《当下的力量》 《如何为爱立界限》 《厌女》 当下生活的重心 # 掌握 HTML、CSS、JavaScript、Tailwind、React、Java 和 SQL 开发前端项目，并创建自己的 Portfolio 网页 将日语口语提高到能工作的水平 能用 Java 和 MySQL 实现基本的增删改查 ","date":"2022-08-14","externalUrl":null,"permalink":"/now/","section":"可爱的小困熊","summary":"Now 页面会随着时间和当下生活的优先级而更新，用来让别人看见这个人现在生活的重点是什么，和提醒自己专注于当下最重要的事。","title":"Now","type":"page"},{"content":" 为自己创作 # 哲学家 Alan Watts 认为自己是“从山边冒出的泉水” — 如果路人喝了泉水并且很享受，这很好，但这不是泉水的目的。\n泉水只是存在。(The spring just exists.)\nAli Abdaal 引用这个例子来说明他对创作的态度：是为了自己写作和拍视频，如果这帮助到了一个人，是一个很棒的附加奖励，但这并不是写作和拍视频的目的。\n只有为自己创作后，才能创作自己想创作的东西，想什么时候创作就什么时候创作，这称为创作自由。\n其中有趣的地方是，Ali 在鼓励新手创作者，说明他们可以创造什么内容时说到：要创造至少对世界上的一个人有帮助的东西。\n这个矛盾的地方是不是可以这么理解：以「创造对别人有用的的东西」为目的只是为一开始的探索期提供灵感，提供内容；当你在探索过程中逐渐得心应手，明白自己想创作什么时，就不必局限在必须为别人创作点什么的想法里，开始以「为自己创作」为目的，才能拥有创作自由，成为那个只是存在着的泉水。\n刚开始创作时：创造至少对世界的上一个人有帮助的东西。 创作得心应手后：为自己创作，对别人有帮助是副加的奖励。 David Perell 的观点是要为自己写作，或者为一个你想吸引的那类读者的一个代表人物写作。\nDavid Perell 强调不要为一群人写作，因为那会让你感到不知所措，只为一个人写作，不管是为你自己，还是为一个想吸引的读者的代表人。\n为自己写作时：思考什么是 6 个月前的自己想要知道的事，专注于那个会让自己感到惊喜的想法。\n为他人写作时：可以在文章的开头写下你想吸引的那类读者的特点，比如：凯文阅读信息的速度非常快，他是一个科技公司的创始人，他对严谨思考的渴望和对空洞想法的不耐烦一样，所以赶紧说重点。\n这对我的启发是，写文章的初心是为自己写，当意识到正在写的东西可能会对一个人有帮助时，要想着这个人去写，就像在酒吧和朋友对话一样，尊重对方，用自然流畅的语言表达你的观点。\n不要只是为自己创作 # 「不要只是为自己创作」是从另一个角度切入的，从是私人写作还是公开写作出发。\n当你在私下写作，这没有为自己写作还是为他人写作之分，私下写作是为自己写作，可能是对过去的自己反思，也可能是对未来的自己喊话。\nDavid Perell 认为不要只是为自己写作，要把你的文章发布在网上。公开写作就像是请朋友到家里做客一样，你会打扫干净你的房间，仔细检查要准备的所有东西。就像你为客人做饭一样，当别人在看着你，你的名誉可能受到威胁时，你会更加努力，社交压力会迫使你提高自己的水平。\n总结 # 公开写作，不要私下写作。 没有创作灵感时，写对他人有帮助的内容，心里想着那一个你想吸引的读者，为他/她创作。 有创作灵感时，为自己创作（也可以为一个人创作），写自己感兴趣的内容，找到创作自由。 Related Posts # How to Find Creative Freedom Write for One Person 独立博客过时以后，为什么开始写博客了？ ","date":"2022-08-12","externalUrl":null,"permalink":"/blog/create-for-whom/","section":"Blog","summary":"在内容创作上，应该以「创造至少对世界上的一个人有帮助的东西」这样的心情去创作，还是以「为自己创造，让帮助到别人这件事成为附加奖励」的心情去创作呢\u0026hellip;","title":"内容创作者应该为谁创作？","type":"blog"},{"content":" 《掌控习惯》这本书主要回答2个问题：\n如何设计你的生活，让好习惯更容易养成？ 如何戒除你一直想戒除的坏习惯？ 《掌控习惯》的英文原名是 Atomic Habits，掌控习惯是一种意译，因为 Atomic 的解释是原子的、微粒子的，没有掌控一意。原名 Atomic Habits 更契合作者在书中讲的微小的习惯在长时间内会有不可估量的影响。\n这篇文章包括这本书内容的简短总结，一些划线高亮和我认为如何把这些技巧应用到生活中的笔记。\n有一位 YouTuber 做的893万次播放量的总结也很值得观看： How to become 37.78 times better at anything | Atomic Habits summary (by James Clear)\n以下是正文。\nChapter 1 - Chapter 3: 习惯的基本原理 # 1%的力量 # 进步1%：好习惯是自我提高的复利，因为习惯的效果会随着你不断地重复而倍增。\n要实现一个目标往往不是通过某个决定性时刻的正确做法，或者大规模的行动和重大转变的结果，而是通过每天进步1%的微小习惯。 一年365天，如果每天进步1%：（1+0.01）^365 = 37.78，一年后将比现在进步37倍。 退步1%：坏习惯是自我毁灭的复利。\n如果日复一日重复1%的错误：反复做出不良决策，重复微小的错误，为自己的小失误寻找借口，久而久之，小选择会叠加成有害的结果。 一年365天，如果每天退步1%：（1-0.01）^365 = 00.03，一年后现有的任何东西会降到几乎为0。 培养习惯的过程中，短期内甚至更长的时间里都看不到任何变化，这时候容易陷入失望而失去进步的动力，只有继续坚持每天1%的进步才能突破临界点，跨入新境界，突破时刻的出现通常是此前一系列行动的结果。\n忘记目标，专注体系。 # 如何让自己坚持足够长的时间，直到达到突破点：「忘记目标，专注体系。」 目标：想要达到的结果 体系：导致这些结果的过程 当你专注于建立和执行你的体系，你想要达成的结果会自然而然地达成。 目标的实现是一种延时的快乐，当你专注于体系，只要你创建的体系在正常运行，你就会在整个过程中感受到快乐。 行为改变的三个层次 # 行为转变的三个层次：结果的变化、过程的变化或和身份的变化。\n结果的变化：改变你的结果。你设定的大多数目标与这个层次的变化相关。 过程的变化：改变你的习惯和体系。你养成的大多数习惯与这个层次的变化相关。 身份的变化：改变你的身份。你持有的大多数信念、假设和偏见都与这个层次的变化相关。 结果意味着你得到了什么，过程意味着你做了什么，身份关系着你相信什么。\n在开始改变习惯时，不要基于最终目标养成习惯，要基于身份养成习惯。即不要专注于想要达成的目标，而要专注于我们希望成为什么样的人。\n真正的行为上的改变是身份的改变。你可能会出于某种动机而培养一种习惯，但让你长期保持这种习惯的唯一原因是它已经与你的身份融为一体。\n目标不是阅读一本书，而是成为读者。\n改变身份的2步过程 # 改变身份的2步过程 决定你想成为哪类人 不断重复成为这类人的行为证明给自己看 决定你想成为哪类人 从你想要的结果开始往回推，弄清楚什么样的人才能得到这些结果。 比如：能著书立说的是什么样的人？这个人可能具有专心致志、诚实可靠的品性。现在你的注意力就从写书（基于结果）转移到成为一个专心致志、诚实可靠的人（基于身份）。 不断重复成为这类人的行为证明给自己看 你的身份来自你的习惯。每个行动都是你在投票给你想成为的人。 你的习惯是体现你身份的方式。一种行为重复的次数越多，与之相关的身份就越是得以强化。你的习惯提供了塑造你身份的大部分证据。 你读了很多次书，你是一个读者的身份得到强化。 养成习惯的4步进程 # 养成习惯的过程可以分为四个简单的步骤：提示、渴求、反应和奖励。\n步骤 举例 提示 看到某一提示，想采取某一行动 看到烟想抽烟，烟是提示。 渴求 采取行动背后的欲望和动力 不是渴求抽烟，而是渴求吸烟带来的解脱感。 回应 将提示和渴求转化为实际行动 因为看到一支烟，想到吸烟能带来的解脱感，真的点了一根烟。 奖励 获得奖励是每个习惯的最终目标 吸了烟之后获得意料之中的满足感。 如果一种行为在这四个阶段中的任何环节做得不够，那么它就不会成为习惯。\n消除提示：你不会开始你的习惯 降低渴求：你没有动力去行动 回应困难：行动很难执行，你将无法付诸实施 奖励不能满足你的愿望：未来没有继续做的理由 习惯循环：提示触发渴求 =\u0026gt; 渴求激发反应 =\u0026gt; 反应提供渴求的奖励 =\u0026gt; 与提示关联\n根据养成习惯的四个步骤，如何培养好习惯与如何戒除坏习惯\n提示 渴求 回应 奖励 培养好习惯 让它显而易见 让它有吸引力 让它简单易行 让它令人愉悦 戒除坏习惯 使其无从显现 使其缺乏吸引力 使其难以施行 使其令人厌烦 Chapter 4 - Chapter 7: 第一定律 让它显而易见 # 将下意识习惯意识化 # 一种行为重复的次数多了以后，会变成一种下意识的习惯，而要改变一种习惯，就要把下意识意识化，保持警觉，知道我们实际在做什么。\n把下意识意识化的一个方法是习惯积分卡：\n列出日常习惯 用“+”好标注好习惯，“-”号标注坏习惯，“=”号标注中性习惯。 创建习惯积分卡后没必要改变任何东西，积分卡的目标只是提醒你注意实际发生的事情，帮助你了解你的行为。\n把下意识意识化的另一个方法是指差确认：识别，指出，大声说出事物的细节。\n在生活中进行指差确认，大声说出你想采取的行动和你预期的结果。 提醒待办的指差确认：大声说出“明天午饭后，我要去邮局”，就能提高你去的可能性。 戒除坏习惯的指差确认：比如你想戒掉吃垃圾食品的习惯，但注意到自己又拿起了一块饼干，你可以大声说：“我要吃这块饼干，但我并不需要它。吃掉它会导致我体重增加，损害我的健康。\n（说出坏习惯的后果让后果触手可及，增加了行动的难度。）\n明确执行习惯的方法 # 执行意图：事先制定何时何行动的计划。 执行意图的应用方式： 时间地点：我将在[时间]和[地点]做[事]。 习惯叠加：继[当前习惯]之后，我将[新习惯]。（让旧习惯成为触发新习惯的提示） 执行意图的好处： 明确执行的细节，消除心血来潮再去做这样模棱两可的说法，就何时、何处、具体做什么制定出具体计划后，就会更有可能贯彻执行。 将有助于你摒弃妨碍你进步、分散注意力，或让你偏离正轨的事情。 创建好习惯的提示显而易见的环境 # 每个习惯都是由提示引发的，我们更有可能注意到显眼的提示。 如果我们的环境充满触发习惯的显眼提示，我们更有可能去执行。 如果激发习惯动作的提示不起眼或隐藏起来时，它们很容易被忽略。 不要将你与环境的关系视作和一个个物体的关系，而是视作与一个个物体之间的关系集合的联系。 一种空间，一种用途：将一个特定的环境和特定的习惯联系起来。比如将沙发和看书这一行为联系起来，餐桌和吃饭这一行为联系，客厅和娱乐这一行为联系。也就意味着沙发上不能打游戏，餐桌上不能工作，客厅不能学习。 在全新的环境中习惯更容易改变。它有助于你远离原有容易促使你恢复旧习惯的触发提示。 创建坏习惯的提示脱离视线的环境 # 你可以改掉一个习惯，但你不太可能忘记它。当你处于易于触发这个习惯的环境中，本来改掉的习惯很可能卷土重来。 你可能能通过意志力短期地改掉坏习惯。但消除坏习惯的最实用的方法之一是避免接触引起它的提示。 Chapter 8 - Chapter 10: 第二定律 让它有吸引力 # 利用绑定喜好使习惯更有吸引力 # 在习惯循环（提示——渴求——回应——奖励）中，多巴胺不仅在获得奖励时分泌，在下一次循环中，在期待获得奖励时，也会分泌多巴胺。\n绑定喜好：把你需要做和愿意做的事绑定。（假如你在做一件事的同时得以做另一件你喜爱的事，那么前者很可能会对你产生一定的吸引力。）\n习惯叠加可以与绑定喜好结合：\n继[当前习惯]之后，我将[我需要的习惯。 继[我需要的习惯]之后，我将[我想要的习惯]。 比如：你特别想查看Facebook上的内容，但是你需要做更多的锻炼：\n在我掏出手机后，我要做十次立卧撑跳（需要）。 在我做了十次立卧撑跳之后，我将能查看脸书上的最新动态。 群体的吸引力 # 当某种行为有助于我们融入团体或社会时，它就具备了吸引力。 培养好习惯的最有效方式之一就是加入一种文化，在这种文化中，你偏爱的行为被认定为是正常行为。当你看到别人每天都这样做时，会觉得培养新习惯似乎并不难。 尽量和那些具备你想拥有的习惯的人在一起，你们会相互促进。 如何让高难度的习惯有吸引力 # 改变看待事情的方式，将负担视为机遇：你不是“得”而是“想”做那些事。Instead of I have to, I got to.\n别再对自己说“我需要一早去跑步”，而要说“是时候增强我的耐力、加快跑步速度了”。 激励仪式：把你的习惯和你喜欢的东西联系起来。\n将一个例行模式与心情愉悦的感受联系起来，比如深呼吸+微笑。 Chapter 11 - Chapter 14: 第三定律 让它简便易行 # 习惯是基于频率而不是基于时长形成的 # 想掌握一种习惯，关键是从重复开始，无需力求完美，只需要不断练习。 习惯的形成是一种行为通过重复变得越来越自动化的过程。自动化是指无须考虑每一个步骤而实施一种行为的能力。 最省力法则 # 在我们可能采取的所有行动中，最终被选择的行动一定是能以最小的努力获得最大价值的那一个。我们被激励着避重就轻，只做容易的事。 习惯坚持起来越难，你和你想要的最终状态之间的阻力就越大。 因减而加：寻找习惯中的每一个消耗时间和精力的阻力点，予以清除，取得事半功倍的效果。 同时可以增加坏习惯的阻力来戒除坏习惯。 2分钟法则 # 2分钟法则：当你开始培养一个新习惯时，它所用时间不应超过2分钟。 一个新习惯不应该让人觉得是挑战，2分钟法则的思路是让习惯尽可能容易开始。比如把“跑步3公里”变成“穿上跑鞋”。“穿上跑鞋”这个个动作只是用来引导你实现期望中结果的仪式。 不要指望从一开始就培养一种完美的习惯，要脚踏实地，连续不断地做些简单的事。先标准化，再优化。 Chapter 15 - Chapter 17: 第四定律 让它令人愉悦 # 人们享受到的快感会教给大脑，某种行为值得回忆和重复。 行为转变的基本规则：重复有即时回报的行为，避免受即使惩罚的行为。 增强法：利用及时奖励来提高行为频度。比如在完成一个习惯时，适当地给自己小奖励。 戒除一个坏习惯时，感到满足几乎不可能，因为你所做的只是在抗拒诱惑，并没有获得任何奖励和满足感。 解决方法是，让戒除习惯的奖励变得显而易见。 想要戒除乱花钱的习惯，每次放弃购买一件物品时，就把等额的数字存入另一个账户，而这个账户可以用来做任何你想做的事情，比如买新电脑，旅游…戒除坏习惯的感受就慢慢变得令人愉悦。 习惯追踪(Habit Tracker) # 习惯跟踪法：取得进步令人满意，借助视觉量度，清晰的看到自己的进步，更容易坚持下去。 习惯追踪的行为本身转化成了奖励的形式。从待办事项列表中划掉一个项目让人感觉心满意足。当感觉不错时，你更有可能坚持下去。习惯追踪让你更关注过程而不是结果。 习惯追踪提供了视觉证据，证明你在把自己塑造成为你特别想成为的那类人，这本身就是一种令人感觉愉快的即时、内在满足的形式。 习惯叠加与习惯追踪结合：在[当前习惯之后，我将[追踪我的习惯]。 习惯被打乱时，如何快速恢复 # 原则：绝不错过两次。 初犯不会毁了你。真正要命的是随之而来的不断重复的错误。错过一次是意外。错过两次是一种新习惯的开始。 书中提供的各种技巧和方法 # 阅读的过程中作者为培养好习惯提供了各种各样的方法，但是读完之后脑子里只有很模糊的印象，所以用表格总结了书中提到的方法和技巧，用 ⭐️ 标注出了我认为最喜欢的方法。\n方法 操作 原则 ⭐️ 忘记目标，专注体系 定下目标以后，制定能达到目标的计划和体系。接下来每天只落实计划，忘记要达成的是什么目标 让习惯坚持下去 习惯积分法 1)列出日常习惯；2)用“+”好标注好习惯，“-”号标注坏习惯，“=”号标注中性习惯 让它显而易见 指差确认 大声说出你想采取的行动和你预期的结果，让无意识习惯意识化 让它显而易见 执行意图 事先制定何时何行动的计划：我将在[时间]和[地点]做[事] 让它显而易见 习惯叠加 继[当前习惯]之后，我将[新习惯]。（让旧习惯成为触发新习惯的提示） 让它显而易见 ⭐️ 创建提示显而易见的环境 如果我们的环境充满触发习惯的显眼提示，我们更有可能去执行 让它显而易见 绑定喜好 把你需要做和愿意做的事绑定，继[我需要的习惯]之后，我将[我想要的习惯] 让它有吸引力 加入群体 当你处在某一群体中，你偏爱的行为被认定为是正常行为。当你看到别人每天都这样做时，会觉得培养新习惯似乎并不难。 让它有吸引力 ⭐️ 转变心态 改变看待事情的方式，将负担视为机遇：你不是“得”而是“想”做那些事。 让它有吸引力 激励仪式 将一个例行模式与心情愉悦的感受联系起来，比如深呼吸+微笑。 让它有吸引力 ⭐️ 2分钟法则 当你开始培养一个新习惯时，它所用时间不应超过2分钟。 让它简单易行 增强法 利用及时奖励来提高行为频度 让它令人愉悦 ⭐️ 习惯跟踪法 从待办事项列表中划掉一个项目让人感觉心满意足。当感觉不错时，你更有可能坚持下去。习惯追踪让你更关注过程而不是结果。 让它令人愉悦 ⭐️ 绝不错过两次 错过一次是意外，错过两次是一种新习惯的开始 让它令人愉悦 Highlights # 身份（identity）这个词最初来源于拉丁语单词essentitas，意思是存在，以及identidem，意思是反复。你的身份实际上就是你的“反复存在”。\n养成习惯的过程实际上就是成为你自己的过程。\n只有让生活的基本要素变得更容易，你才能创造自由思考和创造力所需的精神空间。\n支配我们行为的不是我们的环境中的各类物品，而是我们与它们之间的关系。事实上，这种思路有助于我们思考环境是怎样影响我们的行为的。不要把你的环境想象成充斥着各种物品，要把它想象成各种关系的综合体。\n尽可能避免将一种习惯的情境与另一种习惯的混在一起。一旦你开始混合不同的情境，你就会把各种习惯混为一谈——那些比较容易实行的习惯通常会占上风。\n从短期来看，你可以选择战胜诱惑。从长远来看，我们将成为我们生活环境的产物。\n我们一直想知道“别人会怎么看我”并根据答案相应地改变我们的行为。\n有许多不同的方法来满足相同的潜在动机。一个人可能会通过吸烟缓解情绪。另一个人通过跑步减轻焦虑。你目前的习惯不一定是解决你面临的问题的最佳方式；它们只是你掌握的方法。一旦你把一个解决方案和你需要解决的问题联系起来，你就会不断地反复加以应用。\n我们的行为在很大程度上取决于我们如何解释与我们相关的事件，而未必是事件本身的客观现实。\n实际上习惯本身并不是你想要的。你真正想要的是习惯带来的结果。\n重新设计你的生活，让对你来说最重要的事成为最容易做的事。\n做得比你希望的少总是好过什么都不做。\n不管你如何衡量你的进步，习惯追踪提供了一个简单的方法来让你的习惯更令人满意。每一次测量都给你提供了一点证据，证明你前进的大方向是正确的，并以自己出色的表现为傲，享受到略嫌短暂的即时快乐。\n很多时候，我们在培养习惯时会陷入全有全无的怪圈中。问题不在于出差错，而是如果不能做完美，就干脆不做的错误想法。\nNotes # 忘记目标，专注于每天做的小习惯，比如我要成为一个健康的人，那我就忘记这个目标而是专注于着每天的运动计划，水分的摄入以及油脂和糖分的减少摄入。\n在平时养成一个习惯却迟迟看不到结果的时候提醒自己不要焦虑，我只是在成为我想成为的人，这个目标和身份已经通过每天的行动和投票不断地强化了，从某种意义上来说，我的目标每天都在完成。\n当我要阅读时，不是在一天中心血来潮时读2页，而是把阅读这件事放进日历里，比如9点-9点半阅读30分钟。除了安排具体时间，也可以把读书这件事安排在我已有习惯之后：比如晚上吃完饭后阅读30分钟。\n习惯叠加的其他应用：洗完澡之后涂身体乳，早上刷完牙之后背单词…\n建立阅读的习惯：在手机屏幕的第一页放所有有关阅读的App，创建阅读的提示显而易见的环境。\n不同的环境和不同的行为要有明确的分界线。只在自习室学习，不要在床上学习，因为和床上的提示通常是与睡眠，放松，休息有关的，而学习是一个需要集中注意的专注活动，旧习惯的提示会干扰新习惯形成。\n培养护肤习惯的喜好绑定应用：晚上洗完澡以后，擦身体乳，擦完身体乳后可以看一集喜欢的情景喜剧。\n我想培养写博客的习惯，那就多交一些同样在写博客的朋友，加入博客∏的社区，与周围有同样习惯的人建立关联。\n当我某一天不想写博客，转变看待这件事的心态，不要把写博客视作负担，而是机遇，不是我必须要写博客，而是我有机会展示我的成果，分享我的观点，I got to do this.\n我想培养写博客的习惯，重要的不是每一篇都写得很完美，我只需要坚持写，不停地联系，让写点什么成为习惯，变得自动化，也许开始会写得很简单，没有人愿意看，这都没关系，重要的是我在不断练习的过程中会做得越来越好。\n很早以前在其他地方看过的“2分钟法则”版本是：当一件事情不超过2分钟就能做完，那就立刻去做。”\n当我发布一篇博客后，在日历上划线，用习惯追踪让自己对这一行为产生满足感。\n如果在预定的时间没有发布博客，那么立刻在第二天补上，不能拖延2天以上。\n","date":"2022-08-06","externalUrl":null,"permalink":"/booknote/atomic-habits/","section":"Book Note","summary":"《掌控习惯》这本书主要回答2个问题：","title":"《掌控习惯》：如何设计生活，让好习惯更容易养成？","type":"booknote"},{"content":"","date":"2022-08-06","externalUrl":null,"permalink":"/tags/productivity/","section":"Tags","summary":"","title":"Productivity","type":"tags"},{"content":"独立博客现在（2022）听来像是很古早的产物。独立域名、服务器空间和原创内容组成了独立博客，听起来是很 Geek 的事。独立博客设置了一道技术门栏，进门以后的人都去做技术博客了（误）。\n想写一个博客是近一两年才有的想法，有了想法之后就有了疑惑：\n写博客应该写什么？ 我的文笔不好，写了没人看怎么办？ 如果我想写的东西别人已经写过了，我还有必要写吗？ \u0026hellip; 抱着这样的疑惑和犹豫迟迟没有开始，直到最近读到 Alexey Guzey 的 Why you should start a Blog Right Now 才恍然大悟，鼓励了我把想法付诸实践。\n为什么要写博客？ # 以输入来判断一个人是尤为无聊的 # 上半年在网上看到一段话：\n成就更关乎你输出的影响所带来的真正价值。你可以买全所有的奢侈品，你也可以看完所有的好电影，但这是世界对你的输入。以输入来判断一个人是尤为无聊的。\n这段话像当头一棒把我敲醒，惊觉原来自己一直在接受被动输入。那些制定的读书计划，观影列表，储存的稍后读文章，都是计划着怎么向自己的大脑输入别人的想法。\n突然明白一个个体即使标记自己看了1000本书，1000部电影，他也不过是一个接受了世界很多输入的无聊的人。\n“我也要向世界输出一些东西。”\n于是有了这样的想法。\n好的思考方式不会通过阅读被动获得 # Alexey Guzey 在 Why You Should start a Blog Right Now 中写到：\nYou can read all the self-help books in the world. You can read all the blog posts in the world. It’s not enough. Good thinking doesn’t happen by passive osmosis of other people’s good thinking. You have to actually write essays and journals to debug yourself and your ideas.\n你可以读完世界上所有关于自救的书，读完所有的博客，但这远远不够，好的思考方式不会通过别人好的思考方式被动地渗透给你。你需要真正动笔写博客和日记来为自己和你的想法排错。\n我囤积了几十本待看的书，几十篇稍后读文章，这句话让我明白就算我把这些书和文章一字不落地看完了，我也并不会因此变得更聪明，阅读作者的好想法并不会获得作者写下好想法时的思考方式，写一点什么比看很多更重要。\n你只知道那些你创造的 # Ali Abdaal 在 一期如何建立Second Brain的视频 中提到 “You Only Know What You Make”。\n我们可以读想读的书，看想看的视频，听想听的播客，但你真正知道的，能真正影响你的生活的，能在你的未來項目中用到的，只有那些你创造的。比如读完书后做的读书总结，听完播客后自己写的见解，甚至是平时生活中产生的一个想法\u0026hellip;当我们和自己创造的内容交互，而不是依赖于已经存在的那些别人的材料，我们会对这个内容更熟悉，也可以通过自己的东西做出更有趣的内容来。\n我发现“你只知道那些你创造的东西”这个概念，和费曼学习法类似。费曼学习法认为：\nIf you can’t explain something in simple terms, you don’t understand it.\n如果你不能向其他人简单地解释一件事，那么你就是还没有真正弄懂它。\n向其他人简单地解释一件事，前置条件是“简单的解释”，所以你不能只是简单通过重复念别人的材料来解释，而是要根据别人的材料作自己的理解，再把自己的理解用简单的语句输出，这个输出，这个“简单的理解”，是你“创造”的东西。\n所以我决定，每读过一本书，看完一篇有价值的文章，不要在“看完”这个动作止步和自喜，而是要进一步根据看过的内容去创造，去检验自己是否有真的掌握那些重要的概念。\n写博客的好处 # 学得更快更好 # David Perell 说：\nThe best way to learn faster is to have a stake in the outcome. 学得更快的最好方式是与结果的利害相关。\n当你意识到别人可能在看自己，你会想要做得更好，让自己看起来体面得当，担心自己可能会「不够体面」的潜在风险会让你的大脑像即将面对一盆浇过来的凉水一样警惕清醒。\nDavid Perell 认为公开写作就像邀请别人到家里做客，你会打扫房间，因为希望别人看到自己的家是干净的；会多次检查做饭的食材是否齐全，希望别人吃到的是你的好手艺。\n写博客时为了输出整洁又有清晰的内容，你会在思考，整理知识，用自己的逻辑和语言尽可能讲清楚一件事，而在这个过程中，你会不断地与知识材料交互，从而产生更深的理解。\n这一点与私有笔记不一样，因为私有笔记不管写成什么样也只有自己会看，没有社交压力，不可避免地可以偷懒。但公开写博客，你输出的内容影响着别人会怎么看你，即使想偷懒也会逼自己把不懂的地方搞清楚。\n《Atomic Habits》的作者 James Clear 也说过：\nIf you wish you would take something more seriously, do it publicly… Social pressure forces you to up your game. 如果你希望自己能更认真地对待某件事情，那就公开地去做\u0026hellip;\u0026hellip;社会压力逼你尽量提高你的水平。\n写作是最好的社交 # 如果你有同感，成人之后的交友变得很困难。我的原因大概是：\n缺少交友途径 盲目地去交友需要花时间去确定三观是否合得来，消耗心力 因为社恐，不希望线下社交 而写作是最好的社交方式，因为写作是一种反向的筛选，阅读过你的文章后，对你产生交流兴趣的人已经经过了一层筛选，对方很可能认同你的观点，对某件事有着相同的看法，你们有着一样的兴趣爱好，写作让你更有机率认识到你希望认识的朋友。\n写博客到底要写什么？ # 我在写什么这个问题上纠结了很久，也是我即使知道写博客有好处但是迟迟没能开始的原因。Alexey 和 Ali 启发和指引了我。\nAlexey 推荐写：\n分享个人经验，也许其他人会从中受益 写阅读别人的文章时，自己产生的不同意的观点 写和朋友交流时产生的、别人可能也会感兴趣的想法 收集自己认为很有趣，也许别人也会觉得有趣的东西 Ali 推荐写：\n写至少对世界上一个人有帮助的内容（比如记录组装一台电脑的过程，学习语言时产生的学习心得… 写一本书的总结，从一本书中学到的观点，技巧，见解等 写听完一个播客后一直在脑子里忘不掉的那个观点 探索自己感兴趣的话题中的内容 记录你学到的东西 他们给的建议都是简单可行的，这些建议并不要求你去创造什么有很大价值的东西，只是记录，记录你的想法，记录你的过程，记录你的探索。\nAli 解释他很喜欢的一句话 “Document, don’t create.”：\nCreating content and the concept of that is actually really hard. It feels like a big deal. But if you just think about documenting the stuff that you’re doing anyway. It becomes very easy to find ideas of things to write about.\n创造内容和创建概念实际上非常困难，让人感觉这是件大事。但是，如果只是考虑记录你正在做的事情，很容易就能找到要写的想法。\n为什么写非原创的东西有用？ # 这是 Alexey 在 Why you should start a Blog Right Now 中谈到的我最喜欢的内容。为什么写非原创的东西是有用的？你要写的读书笔记别人可能早就写过了，你记录的学到的东西也是可能别人已经分享过的…\nAlexey 认为：\n这有助于发现和支持那些不被重视的观点 你写的关于这个观点的文章，可能是说服读者去尝试这个观点的最后一遍 我认为第2点很重要，我反思自己作为读者的过程中，确实不太会在第一次看到一个观点时就去做点什么，而是经过一段时间的阅读后，再次遇到相似的观点一次两次，慢慢被说服，逐渐去接受。\n创作歌手 Tessa Violet 在 一期关于创造力的视频中回答评论 “我要怎么才能让我的歌曲听起来是原创的” 时讲这样说：\n如果一直担心自己一定要写出原创的东西，最后可能什么都写不出来。不要给自己压力，不用逼自己一定要原创，一定要写足够好的东西，这可以只是一件你在做的事，请允许你给你的创造力一次机会。\n结语 # 最后回答标题「独立博客过时以后，为什么开始写博客了？」，虽然独立博客是互联网早期的产物，但是它的意义从来没有过时过。自我成长和探索，是贯穿一生的事情。而在这个过程中，记录显得尤为重要，因为没有记录就没有发生，没有记录就会被遗忘。整理自己学到的，记录自己有共鸣的，对世界输出一些什么，通过创造来学习更多，这就是我开始写博客的原因。\n","date":"2022-05-29","externalUrl":null,"permalink":"/blog/why-blog/","section":"Blog","summary":"写作即思考，不是我有什么话要说，是为了弄清楚我到底想说什么。","title":"独立博客过时后，为什么开始写博客了？","type":"blog"},{"content":" About Me # 可爱的小困熊 是网名，你也可以叫我 小笨熊 或 Dylan 。 我从 2022-07 开始写博客，第一篇博客是 独立博客过时后，为什么开始写博客了？ 语言爱好者。目前掌握了汉语(Native)、英语(C2)、西班牙语(C1)、法语(B1)，现在学习日语中(已通过N1)，正在为了 去东京游历 而努力。 我关心前沿技术、UI/UX 设计、生产力工具、书籍、女性主义、个人成长、亲密关系、数字生活等话题。 我非常想多认识一些数学家和计算机科学家。 About Site # 本站生日：2024-06-01 这个 Blog 主要参考了小绵尾巴的建站方案，并使用了 Blowfish 的主题，在此表示感谢! 使用 Hugo 搭建，部署在 GitHub Pages 上： 如何用 GitHub Pages + Hugo 搭建个人博客 Now 页面的灵感来自 Derek Sivers 博客中使用的评论工具是 Cusdis，不需要登陆任何账号即可评论。但也由于没有任何账号的缘故，我回复了你的评论后，你不会收到任何形式的提示，需要之后自己返回评论区查看。如果你需要一来一回有交流的信息，给我发邮件 可能是更好的选择，可以在本页面下方找到我的邮件地址。 Don\u0026rsquo;t be shy, let\u0026rsquo;s connect! # Twitter - 我的 jibber jabber 。 Telegram Channel - 我在这里记录 Today I Learned（TIL），随手保存让我有共鸣，或有启发的互联网碎片信息。 如果有任何问题，或者其他想要交流的信息，我会很高兴收到你的邮件： chanqi4444@gmail.com ","date":"0001-01-01","externalUrl":null,"permalink":"/about/","section":"可爱的小困熊","summary":"About Me # 可爱的小困熊 是网名，你也可以叫我 小笨熊 或 Dylan 。 我从 2022-07 开始写博客，第一篇博客是 独立博客过时后，为什么开始写博客了？ 语言爱好者。目前掌握了汉语(Native)、英语(C2)、西班牙语(C1)、法语(B1)，现在学习日语中(已通过N1)，正在为了 去东京游历 而努力。 我关心前沿技术、UI/UX 设计、生产力工具、书籍、女性主义、个人成长、亲密关系、数字生活等话题。 我非常想多认识一些数学家和计算机科学家。 About Site # 本站生日：2024-06-01 这个 Blog 主要参考了小绵尾巴的建站方案，并使用了 Blowfish 的主题，在此表示感谢!","title":"About","type":"page"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"0001-01-01","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]